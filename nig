if game.PlaceId == 85896571713843 then

do
    local player = game:GetService("Players").LocalPlayer
    local gui = player:WaitForChild("PlayerGui"):WaitForChild("ScreenGui", 10)

    for _, child in ipairs(gui:GetChildren()) do
    	if child.Name == "Prompt" and child:FindFirstChild("Frame") then
    		local title = child.Frame:FindFirstChild("Top") and child.Frame.Top:FindFirstChild("Title")
    		if title and title:FindFirstChild("Label") and title.Label.Text == "Rewards" then
    			child:Destroy()
    		end
    	end
    end

    gui.ChildAdded:Connect(function(child)
    	if child.Name == "Prompt" then
    		task.defer(function()
    			local frame = child:FindFirstChild("Frame")
    			if not frame then return end
    			local title = frame:FindFirstChild("Top") and frame.Top:FindFirstChild("Title")
    			if title and title:FindFirstChild("Label") then
    				local txt = title.Label.Text
    				if txt and txt:match("Rewards") then
    					child:Destroy()
    				end
    			end
    		end)
    	end
    end)

    local rep = game:GetService("ReplicatedStorage")
    local promptModule = rep:FindFirstChild("Client") and rep.Client:FindFirstChild("Gui") and rep.Client.Gui:FindFirstChild("Prompt")
    if promptModule then
    	local env = getsenv(promptModule)
    	if env and env.v_u_69 then
    		local old = env.v_u_69
    		env.v_u_69 = function(p)
    			if p and p.Title == "Rewards" then
    				return
    			end
    			return old(p)
    		end
    	end
    end

    local RS = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local StarterGui = game:GetService("StarterGui")

    local plr = Players.LocalPlayer
    local cam = workspace.CurrentCamera
    local pgui = plr:WaitForChild("PlayerGui")

    local Remote
    local SetCoreGuiEnabled
    local PlayerControls

    pcall(function() Remote = require(RS.Shared.Framework.Network.Remote) end)
    pcall(function() SetCoreGuiEnabled = require(RS.Client.Gui.Utils.SetCoreGuiEnabled) end)
    pcall(function() PlayerControls = require(RS.Client.PlayerControls) end)

    local function getScreenGui()
    	return pgui:FindFirstChild("ScreenGui")
    end

    local function restoreEverything()
    	local gui = getScreenGui()
    	if gui then
    		local HUD = gui:FindFirstChild("HUD")
    		local Buffs = gui:FindFirstChild("Buffs")
    		local MinigameHUD = gui:FindFirstChild("MinigameHUD")
    		if HUD then HUD.Visible = true end
    		if Buffs then Buffs.Visible = true end
    		if MinigameHUD then MinigameHUD.Visible = false end
    	end
    	if SetCoreGuiEnabled and type(SetCoreGuiEnabled) == "function" then
    		pcall(function() SetCoreGuiEnabled(true) end)
    	else
    		pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true) end)
    	end
    	if PlayerControls then
    		pcall(function()
    			if PlayerControls.Enable then PlayerControls:Enable() end
    			if PlayerControls.EnableMaster then PlayerControls:EnableMaster() end
    		end)
    	end
    	pcall(function()
    		local char = plr.Character or plr.CharacterAdded:Wait()
    		local humanoid = char:FindFirstChildOfClass("Humanoid")
    		if humanoid then
    			cam.CameraSubject = humanoid
    		elseif char.PrimaryPart then
    			cam.CameraSubject = char.PrimaryPart
    		end
    		cam.CameraType = Enum.CameraType.Custom
    		if cam.FieldOfView < 40 or cam.FieldOfView > 100 then
    			cam.FieldOfView = 70
    		end
    	end)
    end

    task.defer(function()
    	local playTransPath = RS:WaitForChild("Client"):WaitForChild("Gui"):FindFirstChild("PlayTransition")
    	if not playTransPath then return end
    	local ok, PlayTransition = pcall(require, playTransPath)
    	if not ok or type(PlayTransition) ~= "function" then return end
    	local original = PlayTransition
    	local function fakePlayTransition(title, callback, icon)
    		if type(callback) == "function" then task.defer(callback) end
    	end
    	local replaced = false
    	pcall(function()
    		getfenv().PlayTransition = fakePlayTransition
    		package.loaded[playTransPath] = fakePlayTransition
    		replaced = true
    	end)
    	if not replaced and hookfunction then
    		pcall(function() hookfunction(original, fakePlayTransition) end)
    		replaced = true
    	end
    end)

    task.spawn(function()
    	local blockedNames = {
    		"LoadingScreen",
    		"LoadingGui",
    		"PlayTransition",
    		"MinigameHUD",
    		"MinigameUI",
    		"RoundStart",
    		"FadeScreen",
    	}
    	local function blockUI(obj)
    		local name = string.lower(obj.Name)
    		for _, bad in ipairs(blockedNames) do
    			if string.find(name, string.lower(bad)) then
    				pcall(function()
    					obj.Enabled = false
    					obj.Visible = false
    					obj.Parent = nil
    				end)
    				return
    			end
    		end
    	end
    	for _, gui in ipairs(pgui:GetDescendants()) do
    		if gui:IsA("ScreenGui") then blockUI(gui) end
    	end
    	pgui.DescendantAdded:Connect(function(obj)
    		if obj:IsA("ScreenGui") then
    			task.defer(function() blockUI(obj) end)
    		end
    	end)
    end)

    if SetCoreGuiEnabled and type(SetCoreGuiEnabled) == "function" then
    	local original = SetCoreGuiEnabled
    	SetCoreGuiEnabled = function(flag)
    		if flag == false then return end
    		return original(true)
    	end
    	getfenv().SetCoreGuiEnabled = SetCoreGuiEnabled
    end

    local enforcing = false
    local hbConn, rsConn

    local function startEnforcing(duration)
    	if enforcing then return end
    	enforcing = true
    	local t0 = os.clock()
    	rsConn = RunService.RenderStepped:Connect(restoreEverything)
    	hbConn = RunService.Heartbeat:Connect(restoreEverything)
    	task.spawn(function()
    		while enforcing and (os.clock() - t0) < (duration or 10) do
    			task.wait(0.01)
    		end
    		if enforcing then
    			enforcing = false
    			if rsConn then rsConn:Disconnect() end
    			if hbConn then hbConn:Disconnect() end
    			restoreEverything()
    		end
    	end)
    end

    local function stopEnforcing()
    	enforcing = false
    	if rsConn then rsConn:Disconnect() end
    	if hbConn then hbConn:Disconnect() end
    end

    if Remote then
    	Remote.Event("StartMinigame"):Connect(function()
    		task.delay(0.001, function()
    			restoreEverything()
    			startEnforcing(12)
    		end)
    	end)
    	Remote.Event("MinigameStateChanged"):Connect(function()
    		startEnforcing(8)
    	end)
    	Remote.Event("FinishMinigame"):Connect(function()
    		stopEnforcing()
    		restoreEverything()
    	end)
    end

    task.defer(restoreEverything)

    local function applyHardFovLock(targetCam)
    	targetCam = targetCam or cam
    	if not targetCam or not targetCam:IsA("Camera") then return false end
    	local ok, result = pcall(function()
    		if typeof(getrawmetatable) ~= "function" then error("no getrawmetatable") end
    		local mt = getrawmetatable(targetCam)
    		if not mt then error("no metatable") end
    		local origNew = mt.__newindex
    		if typeof(setreadonly) == "function" then setreadonly(mt, false) end
    		mt.__newindex = function(t, k, v)
    			if t == targetCam and k == "FieldOfView" and v ~= 70 then return end
    			if origNew then return origNew(t, k, v) else return rawset(t, k, v) end
    		end
    		if typeof(setreadonly) == "function" then setreadonly(mt, true) end
    		if targetCam.FieldOfView ~= 70 then pcall(function() targetCam.FieldOfView = 70 end) end
    		_G.__RCH_Loading = false
    return true
end)
    	if ok and result then return true end
    	return false
    end

    local function watchCamera()
    	local applied = false
    	pcall(function() applied = applyHardFovLock(workspace.CurrentCamera) end)
    	if not applied then
    		task.spawn(function()
    			while true do
    				task.wait()
    				if cam and cam.FieldOfView ~= 70 then
    					pcall(function() cam.FieldOfView = 70 end)
    				end
    			end
    		end)
    		return
    	end
    	if workspace:GetAttribute("__FovLockWatcher") then return end
    	workspace:SetAttribute("__FovLockWatcher", true)
    	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    		task.defer(function()
    			local newCam = workspace.CurrentCamera
    			if newCam then
    				task.wait()
    				pcall(function() applyHardFovLock(newCam) end)
    				pcall(function() if newCam.FieldOfView ~= 70 then newCam.FieldOfView = 70 end end)
    			end
    		end)
    	end)
    end

    pcall(watchCamera)
end
-- >>> END fullblocker.lua (inlined) <<<

    local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
    local logs = loadstring(game:HttpGet("https://raw.githubusercontent.com/IRdotAI/Rcash-Hub/refs/heads/main/Secreto.lua"))()
	local NebulaIcons = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/nebula-icon-library-loader"))()

	WindUI.Creator.AddIcons("nebula",    NebulaIcons.nebulaIcons)

    WindUI:Notify({
        Title = "Rcash Hub",
        Content = "Script Successfully loaded and initialized.",
        Duration = 5
    })

WindUI:AddTheme({
    Name = "Rcash",
    Accent = WindUI:Gradient({                                                  
        ["0"] = { Color = Color3.fromHex("#B566FF"), Transparency = 0 },
        ["100"]   = { Color = Color3.fromHex("#7E30E8"), Transparency = 0 },
    }, {
        Rotation = 90,
    }),
    Dialog = Color3.fromHex("#1E003D"),
    Outline = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#B566FF"), Transparency = 0.5 },
        ["50"] = { Color = Color3.fromHex("#9C4DFF"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#7E30E8"), Transparency = 0.5 },
    }, {
        Rotation = 45,
    }),
    Text = Color3.fromHex("#FFFFFF"),
    Placeholder = Color3.fromHex("#A1A1AA"),
    Background = Color3.fromHex("#2C005F"), 
    Button = WindUI:Gradient({
        ["0"] = { Color = Color3.fromHex("#B566FF"), Transparency = 0.5 },
        ["50"] = { Color = Color3.fromHex("#9C4DFF"), Transparency = 0 },
        ["100"] = { Color = Color3.fromHex("#7E30E8"), Transparency = 0.5 },
    }, {
        Rotation = 45,
    }),
    Icon = Color3.fromHex("#A1A1AA")
})

-- Get Services
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local HttpService = game:GetService("HttpService")
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local UserInputService = game:GetService("UserInputService")
    local LocalPlayer = Players.LocalPlayer
    local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
    local ItemUtil = require(ReplicatedStorage.Shared.Utils.Stats.ItemUtil)
    local PowerupsData = require(ReplicatedStorage.Shared.Data.Powerups)
    local RemoteEvent = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent
    local RemoteFunction = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteFunction
    local PhysicalItem = require(ReplicatedStorage.Client.Effects.PhysicalItem)
    local PlayLocalSound = require(ReplicatedStorage.Client.Gui.Utils.PlayLocalSound)

-- Script Version
    local SCRIPT_VERSION = "v1.4"

-- Global Variables
    local autoBlowBubbles = false
    local autoHatch = false
    local autoCS = false
    local selectedEgg = ""
    local autoClaimPTR = false
    local hideHatchAnim = false
    local spamE = false
    local autoCollectPickups = false
    local autoCollectFreeGifts = false
    local autoOpenDailyRewards = false
    local autoSpinHalloweenWheel = false
    local autoSpinFestivalWheel = false
    local autoSpinDarkWheel = false
    local autoBuyAutumnShop = false
    local autoEquipBest = false
    local autoSellPets = false
    local autoObby = false
    local autoClaimHalloweenSpin = false
    local autoClaimFestivalSpin = false
    local autoClaimDarkSpin = false
    local autoGoldenOrb = false
    local selectedGift = "None"
    local autoUseSelectedGift = false
    local skipGiftAnimation = false
    local autoSell = false
    local selectedFallback = "Twilight Overworld"
    local sellTimer = 2
    local autoGift = false
    local waitTime = 2.5
    local giftsToOpen = {}
    local canChangeTheme = true
    local canChangeDropdown = true
    local themeDropdown = nil
    local darkModeToggle = nil
    local autoClaimAllChests = false
    local autoHatchInventoryEggs = false
    local selectedInventoryEgg = "None"
    local inventoryEggDisplayNames = {"None"}
    local isRerolling = false
    local autoSpookyTrack = false
    

-- Gift Controller (PC and Mobile Detection)
    local function isPC()
        return UserInputService.KeyboardEnabled and not UserInputService.TouchEnabled
    end

    local function isMobile()
        return UserInputService.TouchEnabled
    end

    _G.OldGift = _G.OldGift or PhysicalItem.Gift
    _G.PopUpConnection = _G.PopUpConnection or nil
    local genericFolder = Workspace.Rendered:FindFirstChild("Generic")

    local function getLocalData()
        return LocalData:Get()
    end

    local function runGiftController()
        PhysicalItem.Gift = function(giftId, giftType, giftPosition)
            if not _G.AutoGift then return _G.OldGift(giftId, giftType, giftPosition) end
            
            task.spawn(function()
                pcall(function()
                    RemoteEvent:FireServer("ClaimGift", giftId)
                end)
            end)
            
            return nil
        end

        if _G.AutoGift then
            if genericFolder and not _G.PopUpConnection then
                _G.PopUpConnection = genericFolder.ChildAdded:Connect(function(item)
                    if item:IsA("Part") and #item.Name == 36 then
                        item:Destroy()
                    end
                end)
            end
        else
            if _G.PopUpConnection then
                _G.PopUpConnection:Disconnect()
                _G.PopUpConnection = nil
            end
        end

        RemoteEvent:FireServer("SetSetting", "Item Notifications", false)

        if _G.AutoGift then
            for _, gift in pairs(_G.GiftsToOpen) do
                while _G.AutoGift do
                    local am = getLocalData().Powerups[gift] or 0
                    if am > 0 then
                        RemoteEvent:FireServer(
                            "UseGift",
                            gift,
                            (am > 25 and 25) or am
                        )
                        task.wait(_G.WaitTime)
                    else
                        break
                    end
                end
            end
        end
    end

    if isPC() then
        WindUI:Notify({
            Title = "Rcash Hub ",
            Content = "Detected PC platform, running PC Gift Controller.",
            Duration = 3
        })
        task.spawn(runGiftController)
    elseif isMobile() then
        WindUI:Notify({
            Title = "Rcash Hub ",
            Content = "Detected Mobile platform, running Mobile Gift Controller.",
            Duration = 3
        })
        task.spawn(runGiftController)
    end

-- Data Tables
    local EggCoordinates = {
        ["Candle Egg"] = Vector3.new(108.63, 8.76, 238.62),
        ["Autumn Egg"] = Vector3.new(109.51, 8.78, 226.32),
        ["Infinity Egg"] = Vector3.new(-96.35, 7.87, -26.89), 
        ["Common Egg"] = Vector3.new(-84.14, 9.35, 1.18), 
        ["Spotted Egg"] = Vector3.new(-93.88, 9.35, 8.61), 
        ["Iceshard Egg"] = Vector3.new(-117.46, 9.37, 8.86), 
        ["Inferno Egg"] = Vector3.new(49.95, 8.83, -11.48), 
        ["Spikey Egg"] = Vector3.new(-127.22, 9.35, 6.10), 
        ["Magma Egg"] = Vector3.new(-134.50, 9.35, 1.00), 
        ["Crystal Egg"] = Vector3.new(-140.09, 9.36, -7.68), 
        ["Lunar Egg"] = Vector3.new(-141.54, 9.36, -16.74), 
        ["Void Egg"] = Vector3.new(-145.26, 9.35, -25.22), 
        ["Hell Egg"] = Vector3.new(-145.92, 9.39, -36.04), 
        ["Nightmare Egg"] = Vector3.new(-140.27, 9.36, -44.64), 
        ["Rainbow Egg"] = Vector3.new(-135.30, 9.35, -52.03), 
        ["Showman Egg"] = Vector3.new(-128.89, 9.36, -59.25), 
        ["Mining Egg"] = Vector3.new(-120.77, 9.35, -63.88), 
        ["Cyber Egg"] = Vector3.new(-93.34, 9.61, -63.77), 
        ["Neon Egg"] = Vector3.new(-82.85, 9.42, -57.32), 
        ["Chance Egg"] = Vector3.new(9837.83, 26.88, 170.67), 
        ["Icy Egg"] = Vector3.new(-57.97, 12.35, -0.84), 
        ["Vine Egg"] = Vector3.new(-64.54, 12.34, 7.92), 
        ["Lava Egg"] = Vector3.new(-72.49, 12.39, 15.93), 
        ["Secret Egg"] = Vector3.new(0, 0, 0), 
        ["Atlantis Egg"] = Vector3.new(-81.63, 12.35, 20.79), 
        ["Classic Egg"] = Vector3.new(-90.61, 12.34, 25.22),
        ["Pumpkin egg"] = Vector3.new(-4907.68, 25.20, -548.46),
        ["Costume egg"] = Vector3.new(-4917.93, 25.20, -548.29),
        ["Sinister egg"] = Vector3.new(-4929.31, 25.23, -548.13),
        ["Mutant Egg"] = Vector3.new(-4940.45, 25.19, -546.39),
        ["Puppet Egg"] = Vector3.new(-5034.52, 10.95, -75.46),
        ["Dreamer Egg"] = Vector3.new(-8529.70312, 6.50242758, 10461.3945),
}

local function __getFallbackEggList()
    local ok, list = pcall(function() return EggDisplayNames end)
    if type(list) == "table" and #list > 0 then return list end
    local names = {}
    local ok2 = pcall(function()
        for k in pairs(EggCoordinates or {}) do table.insert(names, k) end
    end)
    if not ok2 or #names == 0 then
        names = {"Common Egg","Spotted Egg","Iceshard Egg","Spikey Egg","Magma Egg","Crystal Egg","Lunar Egg","Void Egg","Hell Egg","Rainbow Egg"}
    end
    table.sort(names)
    return names
end

local function __tpFallbackEgg(name)
    if not name or name == "" then return end
_G.__tpFallbackEgg = __tpFallbackEgg

    if typeof(TeleportToEgg) == "function" then
        TeleportToEgg(name)
    else
        local pos = EggCoordinates and EggCoordinates[name]
        local lp = game:GetService("Players").LocalPlayer
        local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        if pos and hrp then hrp.CFrame = CFrame.new(pos + Vector3.new(5,3,0)) end
    end
end

__HunterFallback = __HunterFallback or { enabled = false, egg = nil }
__HunterLastSelectedEgg = __HunterLastSelectedEgg or nil

__SpawnerFallback = __SpawnerFallback or { enabled = false, egg = nil }
__AutoRespawnEnabled = __AutoRespawnEnabled or false
__FallbackGuard = __FallbackGuard or {
    egg = nil,
    radius = 20,
    interval = 1.0, 
    running = false,
    lastTp = 0,
}

local function __eggPos(name)
    return EggCoordinates and EggCoordinates[name]
end

local function __nearPos(pos, r)
    local lp = game:GetService("Players").LocalPlayer
    local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not (hrp and pos) then return false end
    return (hrp.Position - pos).Magnitude <= (r or __FallbackGuard.radius)
end

local function __ensureNearFallbackOnce(name)
if __UseFarmingFallback and _G.FarmingEggPosition then
    local lp = game:GetService("Players").LocalPlayer
    local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        local dist = (hrp.Position - _G.FarmingEggPosition).Magnitude
        if dist > 12 and (os.clock() - __FallbackGuard.lastTp) > 1.25 then
            __FallbackGuard.lastTp = os.clock()
            hrp.CFrame = CFrame.new(_G.FarmingEggPosition + Vector3.new(0, 3, 0))
        end
    end
    return
end

    if not name or name == "" then return end
    local pos = __eggPos(name)
    if not __nearPos(pos) and (os.clock() - __FallbackGuard.lastTp) > 1.25 then
        __FallbackGuard.lastTp = os.clock()
        local fn = _G.__tpFallbackEgg or __tpFallbackEgg
        if type(fn) == "function" then
            fn(name)
        elseif typeof(TeleportToEgg) == "function" then
            TeleportToEgg(name)
        end
    end
end

function __startFallbackWatch(name)
if not __RiftHunterEnabled or not __FallbackEnabled then
    return
end
    __FallbackGuard.egg = name
    if __FallbackGuard.running then return end
    __FallbackGuard.running = true

    local startE = _G.StartAutoPressE or __safeStartE
    if type(startE) == "function" then
        startE(nil, 0.02, 0.005)
    end

    task.spawn(function()
        while __FallbackEnabled and __FallbackGuard.egg == name do
            __ensureNearFallbackOnce(name)
            task.wait(__FallbackGuard.interval)
        end
        __FallbackGuard.running = false
        if _G.StopAutoPressE then _G.StopAutoPressE() end
    end)
end

function __stopFallbackWatch()
    __FallbackGuard.egg = nil
    __FallbackGuard.running = false
    if _G.StopAutoPressE then _G.StopAutoPressE() end
end


local __RespawnDisposer

local function __attachRiftLifecycleWatcher(expectedName, onGone)
    if __RespawnDisposer then pcall(__RespawnDisposer) end
    local folder = workspace:FindFirstChild("Rendered")
    folder = folder and folder:FindFirstChild("Rifts")
    if not folder then return end

    local expected = string.lower(tostring(expectedName or ""))
    local conns = {}

    local function bind(r)
        if string.lower(r.Name) ~= expected then return end
        table.insert(conns, r.AncestryChanged:Connect(function(obj, parent)
            if obj == r and parent == nil then
                for _, c in ipairs(conns) do pcall(function() c:Disconnect() end) end
                conns = {}
                if typeof(onGone) == "function" then onGone() end
            end
        end))
    end

    for _, child in ipairs(folder:GetChildren()) do
        if string.lower(child.Name) == expected then
            bind(child)
        end
    end

    table.insert(conns, folder.ChildAdded:Connect(function(child)
        if string.lower(child.Name) == expected then
            bind(child)
        end
    end))

    __RespawnDisposer = function()
        for _, c in ipairs(conns) do pcall(function() c:Disconnect() end) end
        conns = {}
    end
end

    local EggDisplayNames = {}
_G.EggNames = _G.EggNames or EggDisplayNames

    for displayName in pairs(EggCoordinates) do table.insert(EggDisplayNames, displayName) end

    local GiftDisplayNames = {"None"}
    local playerDataForGifts = LocalData:Get()
    if playerDataForGifts and playerDataForGifts.Powerups then
        local ownedGifts = {}
        for name, count in pairs(playerDataForGifts.Powerups) do
            if PowerupsData[name] and PowerupsData[name].Type == "Gift" and count > 0 then
                table.insert(ownedGifts, {Name = name, Count = count})
            end
        end
        table.sort(ownedGifts, function(a, b) return a.Name < b.Name end)
        for _, giftInfo in ipairs(ownedGifts) do
            table.insert(GiftDisplayNames, ("%s: %d"):format(giftInfo.Name, giftInfo.Count))
        end
    end

    local sellPositions = {
        ["Twilight Overworld"] = Vector3.new(-70.92, 6861.75, 116.3),
        ["Base (W1 Surface)"] = Vector3.new(77.24, 8.46, -112.75),
        ["Minigame World W2 Surface"] = Vector3.new(9921.87, 25.88, 137.44),
        ["Minigame World Robot Factory"] = Vector3.new(9853.21, 13408.82, 241.91),
        ["Bubble Rift"] = Vector3.new(-326.35, 27.87, 192.93)
    }

    local inventoryEggTypes = {
        "Season 8 Egg",
        "Stellaris Egg",
        "Spooky Egg",
        "Easter Egg",
        "Season 7 Egg",
        "Milestone Egg",
        "Event Reward Egg"
    }

    local AllEnchants = {
        "Bubbler I", "Bubbler II", "Bubbler III", "Bubbler IV", "Bubbler V", "Gleaming I", "Gleaming II", "Gleaming III",
        "Looter I", "Looter II", "Looter III", "Looter IV", "Looter V", "Team Up I", "Team Up II", "Team Up III", "Team Up IV", "Team Up V",
        "High Roller", "Infinity", "Magnetism", "Secret Hunter", "Ultra Roller", "Determination", "Shiny Seeker"
    }
    local enchantLookup = {}
    getgenv().__AutoPressE = getgenv().__AutoPressE or { enabled = false }

    local VIM = game:GetService("VirtualInputManager")

    _G.StartProximityEForRift = function(rift, enableDist, disableDist, spamInterval, pulse)
        local state = getgenv().__AutoPressE
        if state.enabled then return end
        state.enabled = true

        interval = math.clamp(tonumber(interval) or 0.02, 0.005, 0.2)
        pulse    = math.clamp(tonumber(pulse)    or 0.005, 0.003, interval * 0.5)

        local t0 = os.clock()
        task.spawn(function()
            while state.enabled and (not maxSeconds or os.clock() - t0 < maxSeconds) do
                VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                task.wait(pulse)
                VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                task.wait(math.max(0, interval - pulse))
            end
            state.enabled = false
        end)
    end

    local function stopAutoPressE()
        getgenv().__AutoPressE.enabled = false
    end


-- Functions
    function AutoBlowBubbles()
        while _G.AutoBlowBubbles do
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("BlowBubble")
            task.wait(0.3)
        end
    end

    function AutoHatch()
        TeleportToEgg(_G.SelectedEgg)
        while _G.AutoHatch do
            if _G.SelectedEgg ~= "" then 
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("HatchEgg",_G.SelectedEgg,15)
            end
            task.wait(0.3) 
        end
    end

    function AutoEquipBest()
        while _G.AutoEquipBest do
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("EquipBestPets")
            task.wait(5) 
        end
    end

    function AutoSellPets() 
        while _G.AutoSellPets do                                                                                                                                                                                                                                 
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("SellPets")
            task.wait(5)
        end
    end

    function SpamEKey()
        while _G.SpamE do
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(0.05) 
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(0.05)
        end
    end

    local function CollectPickups()
        for i, v in next, game:GetService("Workspace").Rendered:GetChildren() do
            if v.Name == "Chunker" then
                for i2, v2 in next, v:GetChildren() do
                    local Part, HasMeshPart = v2:FindFirstChild("Part"), v2:FindFirstChildWhichIsA("MeshPart")
                    local HasStars = Part and Part:FindFirstChild("Stars")
                    local HasPartMesh = Part and Part:FindFirstChild("Mesh")
                    if HasMeshPart or HasStars or HasPartMesh then
                        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Pickups"):WaitForChild("CollectPickup"):FireServer(v2.Name)
                        v2:Destroy()
                    end
                end
            end
        end
    end

    function AutoPickupLoop()
        while true do
            if _G.AutoCollectPickups then pcall(CollectPickups) end
            task.wait(1)
        end
    end

    local HatchEgg = nil
    local success, result = pcall(function()
        return require(ReplicatedStorage.Client.Effects:WaitForChild("HatchEgg", 5))
    end)

    if success and typeof(result) == "table" then
        HatchEgg = result
    
        if HatchEgg and typeof(HatchEgg.Play) == "function" then
            local OriginalPlay = HatchEgg.Play
            local PromiseResolve = nil
            local Promise = Promise or {}
        
            if typeof(Promise) == "table" and Promise.resolve and typeof(Promise.resolve) == "function" then
                PromiseResolve = Promise.resolve
            end

            HatchEgg.Play = function(...)
                if _G.HideHatchAnim then
                    return PromiseResolve and PromiseResolve() or nil
                else
                    return OriginalPlay(...)
                end
            end
        else
            warn("Rcash Hub : Found HatchEgg module, but could not hook the 'Play' function.")
        end
    else
        warn("Rcash Hub : Failed to load the core HatchEgg module:", result)
    end

    -- REPLACE your existing TeleportToEgg function with this:

    function TeleportToEgg(EggName)
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HRP = Character and Character:FindFirstChild("HumanoidRootPart")
        if not HRP then
            WindUI:Notify({
                Title = "Rcash Hub ",
                Content = "Error: Character or HumanoidRootPart not found.",
                Duration = 3,
                Icon = "shield-alert",
            })
            return
        end

        -- Special case: Farming Egg bookmark
        if EggName == "__FARMING_EGG__" or EggName == "Farming Egg" then
            if _G.FarmingEggPosition then
                HRP.CFrame = CFrame.new(_G.FarmingEggPosition + Vector3.new(0, 3, 0))
                WindUI:Notify({
                    Title = "Rcash Hub",
                    Content = "Teleported to Farming Egg.",
                    Duration = 3,
                    Icon = "navigation",
                })
            else
                WindUI:Notify({
                    Title = "Rcash Hub",
                    Content = "No Farming Egg set. Use âSet Farming Eggâ in Auto Farming.",
                    Duration = 4,
                    Icon = "map-pin-off",
                })
            end
            return
        end

        -- Normal eggs
        local EggPos = EggCoordinates[EggName]
        if EggPos then
            HRP.CFrame = CFrame.new(EggPos + Vector3.new(5, 3, 0))
            WindUI:Notify({
                Title = "Rcash Hub ",
                Content = "Teleported to: " .. EggName,
                Duration = 3
            })
        else
            WindUI:Notify({
                Title = "Rcash Hub ",
                Content = "Error: No coordinates found for " .. EggName,
                Duration = 3,
                Icon = "egg-off",
            })
        end
    end

    
    function AutoCS()
        while _G.AutoCS do
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimSeason")
            task.wait(1)
        end
    end

    function AutoClaimPTR()
        while _G.AutoClaimPTR do
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimAllPlaytime")
            task.wait(30) 
        end
    end

    function AutoHatchInventoryEggs()
        while _G.AutoHatchInventoryEggs do
            local playerData = LocalData:Get()
            if playerData and playerData.Powerups and _G.SelectedInventoryEgg ~= "None" then
                local amount = playerData.Powerups[_G.SelectedInventoryEgg] or 0
                if amount > 0 then
                    pcall(function()
                        RemoteEvent:FireServer("HatchPowerupEgg", _G.SelectedInventoryEgg, math.min(15, amount))
                        if amount <= 15 then
                            _G.AutoHatchInventoryEggs = false
                            WindUI:Notify({
                                Title = "Rcash Hub ",
                                Content = "Ran out of " .. _G.SelectedInventoryEgg .. ". Auto-Hatch stopped.",
                                Duration = 3,
                                Icon = "egg-off",
                            })
                        end
                    end)
                else
                    _G.AutoHatchInventoryEggs = false
                    WindUI:Notify({
                        Title = "Rcash Hub ",
                        Content = "No " .. _G.SelectedInventoryEgg .. " left. Auto-Hatch stopped.",
                        Duration = 3,
                        Icon = "egg-off",
                    })
                end
            end
            task.wait(0.5)
        end
    end

    local function updateInventoryEggDropdown()
        local playerData = LocalData:Get()
        if playerData and playerData.Powerups then
            inventoryEggDisplayNames = {"None"}
            local ownedEggs = {}
            for name, count in pairs(playerData.Powerups) do
                if count > 0 and string.find(name:lower(), "egg") then
                    table.insert(ownedEggs, {Name = name, Count = count})
                end
            end
            table.sort(ownedEggs, function(a, b) return a.Name < b.Name end)
            for _, eggInfo in ipairs(ownedEggs) do
                table.insert(inventoryEggDisplayNames, ("%s: %d"):format(eggInfo.Name, eggInfo.Count))
            end
            if inventoryEggDropdown then
                inventoryEggDropdown:Refresh(inventoryEggDisplayNames, _G.SelectedInventoryEgg)
            end
        end
    end

    task.spawn(function()
        while true do
            updateInventoryEggDropdown()
            task.wait(5)
        end
    end)
    
    function AutoUseSelectedGift()
        local baseAmountToUse, useInterval = 25, _G.WaitTime
        while _G.AutoUseSelectedGift do
            local s, r = pcall(function()
                if getgenv() and getgenv().NETWORK_PAUSED then return end
                if not _G.SelectedGift or _G.SelectedGift == "None" then
                    _G.AutoUseSelectedGift = false; return
                end
                local playerData = LocalData:Get(); if not playerData then return end
                local currentAmount = playerData.Powerups[_G.SelectedGift] or 0
                if currentAmount > 0 then
                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("UseGift", _G.SelectedGift, math.min(baseAmountToUse, currentAmount))
                else
                    _G.AutoUseSelectedGift = false
                    WindUI:Notify({
                        Title = "Rcash Hub",
                        Content = "Ran out of " .. _G.SelectedGift .. ". Auto-Use stopped.",
                        Duration = 1,
                        Icon = "gift",
                    })
                end
            end)
            if not s then warn("AutoGift Loop Error:", r) end
            task.wait(useInterval)
        end
    end

    function SpinHalloweenWheel()
        while _G.AutoSpinHalloweenWheel do
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteFunction:InvokeServer("HalloweenWheelSpin") end)
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimHalloweenWheelSpinQueue") end)
            task.wait(0.3)
        end
    end

    function SpinDarkWheel()
        while _G.AutoSpinDarkWheel do
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteFunction:InvokeServer("DarkWheelSpin") end)
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimDarkWheelSpinQueue") end)
            task.wait(0.3)
        end
    end

    function SpinFestivalWheel()
        while _G.AutoSpinFestivalWheel do
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteFunction:InvokeServer("FestivalWheelSpin") end)
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimFestivalWheelSpinQueue") end)
            task.wait(0.3)
        end
    end

    function AutoClaimHalloweenSpin()
        while _G.AutoClaimHalloweenSpin do
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimHalloweenFreeWheelSpin") end)
            task.wait(30) 
        end
    end

    function AutoClaimDarkSpin()
        while _G.AutoClaimDarkSpin do
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimDarkFreeWheelSpin") end)
            task.wait(30) 
        end
    end

    function AutoClaimFestivalSpin()
        while _G.AutoClaimFestivalSpin do
            pcall(function() game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimFestivalFreeWheelSpin") end)
            task.wait(30) 
        end
    end

    function AutoSpookyTrack()
        while _G.AutoSpookyTrack do
            pcall(function()game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ChallengePassClaimReward") end)
            task.wait(1) 
        end
    end

    local DIFFICULTIES_TO_CYCLE = { "Easy", "Medium", "Hard" }
    local TELEPORT_DELAY = 2.5

    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    local LocalPlayer = Players.LocalPlayer

    local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
    local RemoteEvent = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent
    local ObbysFolder = Workspace.Obbys
    local ObbyTeleports = Workspace.Worlds["Seven Seas"].Areas["Classic Island"].Obbys

    local function teleportTo(target)
        local character = LocalPlayer.Character
        if not character or not target then return end
        local targetCFrame
        if typeof(target) == "CFrame" then
            targetCFrame = target
        elseif target:IsA("BasePart") then
            targetCFrame = target.CFrame
        elseif target:IsA("Model") then
            targetCFrame = target:GetPivot()
        end
        if targetCFrame then
            character:PivotTo(targetCFrame * CFrame.new(0, 3, 0))
        end
    end

    local function runObbyCycle(difficulty)
        if not _G.AutoObby then return end
        
        local teleportPart = ObbyTeleports:FindFirstChild(difficulty) 
            and ObbyTeleports[difficulty]:FindFirstChild("Portal") 
            and ObbyTeleports[difficulty].Portal:FindFirstChild("Part")
        local completePart = ObbysFolder:FindFirstChild(difficulty) and ObbysFolder[difficulty]:FindFirstChild("Complete")
    
        if not teleportPart or not completePart then
            return
        end
    
        teleportTo(teleportPart)
        task.wait(0.5)
        RemoteEvent:FireServer("StartObby", difficulty)
        task.wait(TELEPORT_DELAY)
        teleportTo(completePart)
        task.wait(0.5)
        RemoteEvent:FireServer("CompleteObby")
        task.wait(0.5)

        local startTime = os.clock()
        while os.clock() - startTime < 30 and _G.AutoObby do
            RemoteEvent:FireServer("ClaimObbyChest")
            task.wait(0.7)
        end
    end

    task.spawn(function()
        while true do
            task.wait(1)
            if not _G.AutoObby then continue end  -- Skip if toggled off
            local character = LocalPlayer.Character
            local playerData = LocalData:Get()
            if not character or not character.PrimaryPart or not playerData or not playerData.ObbyCooldowns then
                continue
            end
            local initialPosition = character.PrimaryPart.CFrame
            local completedAnObbyInCycle = false
            for _, difficulty in ipairs(DIFFICULTIES_TO_CYCLE) do 
                if not _G.AutoObby then break end  -- Bail if toggled off mid-cycle
                local cooldownEndTime = playerData.ObbyCooldowns[difficulty] or 0
                if os.time() >= cooldownEndTime then
                    runObbyCycle(difficulty)
                    completedAnObbyInCycle = true
                    task.wait(3)
                    playerData = LocalData:Get()
                    if not playerData or not playerData.ObbyCooldowns then break end
                end
            end
            if completedAnObbyInCycle then
                teleportTo(initialPosition)
            end
            playerData = LocalData:Get()
            if not playerData or not playerData.ObbyCooldowns then continue end
            local nextAvailableTime = math.huge
            for _, difficulty in ipairs(DIFFICULTIES_TO_CYCLE) do
                local cooldownEndTime = playerData.ObbyCooldowns[difficulty] or 0
                if cooldownEndTime > os.time() and cooldownEndTime < nextAvailableTime then
                    nextAvailableTime = cooldownEndTime
                end
            end
            if nextAvailableTime ~= math.huge then
                local timeToWait = nextAvailableTime - os.time()
                if timeToWait > 0 then
                    
                    task.wait(timeToWait)
                end
            end
        end
    end)

    function AutoGoldenOrb()
        while _G.AutoGoldenOrb do
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("UseGoldenOrb")
            task.wait(0.1)
        end
    end

    local function FindGumRiftPosition()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Position.Y >= 10125 and obj.Position.Y <= 15955 then
                if obj.Name:lower():find("sell") or (obj.Parent and obj.Parent.Name:lower():find("rift")) then
                    return obj.Position
                end
            end
        end
        return nil
    end

    function AutoSellFunction()
        spawn(function()
            while _G.AutoSell do
                local player = game.Players.LocalPlayer
                local char = player.Character
                if not char or not char:FindFirstChild("HumanoidRootPart") then
                    wait(1)
                    continue
                end

                -- Capture original position before any TP
                local originalPos = char.HumanoidRootPart.Position
                -- Debug

                -- Check for x250 rift
                local riftPos = FindGumRiftPosition()
                local sellPos
                if riftPos then
                    sellPos = riftPos
                else
                    -- Fallback
                    sellPos = sellPositions[_G.SelectedFallback]
                end

                if sellPos then
                    -- Intermediate TP to Output for W2 areas
                    if _G.SelectedFallback == "Minigame World W2 Surface" or _G.SelectedFallback == "Minigame World Robot Factory" then
                        local outputPart = workspace.Worlds["Minigame Paradise"].Output
                        if outputPart and outputPart:IsA("BasePart") then
                            char.HumanoidRootPart.CFrame = CFrame.new(outputPart.Position + Vector3.new(0, 3, 0))
                            wait(0.5)  -- Wait to stabilize
                        end
                    end

                    -- Teleport to sell location with offset
                    char.HumanoidRootPart.CFrame = CFrame.new(sellPos + Vector3.new(0, 3, 0))

                    wait(0.5)  -- Wait for sell to process
                    wait(1)    -- Wait 1 second to capture updated position
                    originalPos = char.HumanoidRootPart.Position  -- Update original position after sell
                    -- Debug
                end

                -- Teleport back to updated original position
                char.HumanoidRootPart.CFrame = CFrame.new(originalPos)
                -- Debug

                -- Wait for the next cycle based on timer
                wait(_G.SellTimer)
            end
        end)
    end

    function AutoClaimAllChests()
        while _G.AutoClaimAllChests do
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimChest","Giant Chest",true)
            task.wait(0.2)
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimChest","Void Chest",true)
            task.wait(0.2)
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent:FireServer("ClaimChest","Ticket Chest",true)
            task.wait(10)
        end
    end

    local function parseEnchantName(name)
        local romanMap = { I = 1, II = 2, III = 3, IV = 4, V = 5 }
        local baseName, roman = name:match("^(.*) (%S+)$")
        local level = romanMap[roman]
        if baseName and level then
            return { id = baseName:lower():gsub(" ", "-"), level = level }
        else
            return { id = name:lower():gsub(" ", "-"), level = 1 }
        end
    end

    for _, fullName in ipairs(AllEnchants) do
        local parsed = parseEnchantName(fullName)
        if not enchantLookup[parsed.id] then enchantLookup[parsed.id] = {} end
        enchantLookup[parsed.id][parsed.level] = fullName
    end

    local function getEquippedPetsData()
        local petsData = {}
        local playerData = LocalData:Get()
        if not (playerData and playerData.TeamEquipped and playerData.Teams and playerData.Pets) then return {} end
        local equippedTeamId = playerData.TeamEquipped
        local teamInfo = playerData.Teams[equippedTeamId]
        if not (teamInfo and teamInfo.Pets) then return {} end
        local petDataMap = {}
        for _, petData in pairs(playerData.Pets) do petDataMap[petData.Id] = petData end
        for _, petId in ipairs(teamInfo.Pets) do
            local petInfo = petDataMap[petId]
            if petInfo then
                local nameParts = {}
                if petInfo.Mythic then table.insert(nameParts, "mythic") end
                table.insert(nameParts, petInfo.Name or "unknown pet")
                if petInfo.Enchants and next(petInfo.Enchants) then
                    local enchantNames = {}
                    for _, enchantData in pairs(petInfo.Enchants) do
                        local fullName = enchantLookup[enchantData.Id] and enchantLookup[enchantData.Id][enchantData.Level]
                        table.insert(enchantNames, fullName or enchantData.Id)
                    end
                    table.insert(nameParts, "(" .. table.concat(enchantNames, ", ") .. ")")
                end
                table.insert(petsData, { name = table.concat(nameParts, " "), id = petId })
            end
        end
        return petsData
    end

    local function hasDesiredEnchant(petInfo, targetEnchants)
        if not petInfo.Enchants then return nil end
        for _, currentEnchant in pairs(petInfo.Enchants) do
            for _, targetEnchant in ipairs(targetEnchants) do
                if currentEnchant.Id == targetEnchant.id and currentEnchant.Level == targetEnchant.level then
                    return enchantLookup[currentEnchant.Id][currentEnchant.Level]
                end
            end
        end
        return nil
    end

    local equippedPetsData = getEquippedPetsData()
    local currentSelectedPetNames = {}
    local currentSelectedEnchants = {}
    local currentRerollSpeed = 0.4
    
-- Main Window
    _G.WindowRef = nil
local Window = WindUI:CreateWindow({
        Title = "Rcash Hub",
        Icon = "nebula:nebula",
        Author = "@RdotA",
        Folder = "RdotA",
		Background = "rbxassetid://114269510951824",
        BackgroundImageTransparency = 0.90,
        Size = UDim2.fromOffset(580, 490),
        Theme = "Rcash",
        SideBarWidth = 180,
    })
_G.WindowRef = Window


    Window:Tag({
        Title = SCRIPT_VERSION,
        Color = Color3.fromHex("#30ff6a"),
        Radius = 13,
    })
    
    Window:Tag({
        Title = "BGSI",
        Color = Color3.fromHex("#c300ff"),
        Radius = 13,
    })


local FPSTag = nil


    Window:SetToggleKey(Enum.KeyCode.RightControl)

    Window:CreateTopbarButton("theme-switcher", "moon", function()
        local newTheme = WindUI:GetCurrentTheme() == "Dark" and "Light" or "Dark"
        WindUI:SetTheme(newTheme)
        if canChangeTheme and darkModeToggle then
            darkModeToggle:Set(newTheme == "Dark")
        end
        if canChangeDropdown and themeDropdown then
            themeDropdown:Set(newTheme)
        end
    end, 990)

    Window:EditOpenButton({
        Title = "Open Rcash Hub",
        Icon = "nebula:nebula",
        CornerRadius = UDim.new(0,12),
        StrokeThickness = 2,
        Color = ColorSequence.new(
            Color3.fromHex("#4b4a4a"), 
            Color3.fromHex("#aaa8af")
        ),
        OnlyMobile = true,
        Enabled = true,
        Draggable = true,
    })

-- >>> BEGIN: Tab order prelude (auto-inserted) >>>
_G.__Tabs = _G.__Tabs or {}

-- Helper to safely create-or-reuse a tab
local function EnsureTab(key, props)
    if not _G.__Tabs[key] then
        _G.__Tabs[key] = Window:Tab(props)
    end
    return _G.__Tabs[key]
end

-- Pre-create tabs in the requested order so later code can just attach sections.
local InfoTab      = EnsureTab("Info",      { Title = "Information",     Icon = "info",                       Locked = false })

-- == BEGIN: Suggestions Tab (merged from suggestionstab.lua) ==
local suggestionsTab = Window:Tab({Title = "Suggestions", Icon = "message-circle", Locked = false})

suggestionsTab:Paragraph({Title = "Write your suggestions below and try to be as detailed as possible please. â¤"})

local HttpService = game:GetService("HttpService")
local WEBHOOK_URL = "https://discord.com/api/webhooks/1430570387137368215/d8Flo_ZESwIRFh5bqOEweQF-KW8eW1csAYjlqEXdvtnpbgXeKCxpGFypqTHVvDIYywx0"
local request = http_request or request or (syn and syn.request) or (fluxus and fluxus.request) or (http and http.request)

local inputText = ""
local cooldown = false
local cooldownTime = 10

local suggestionInput = suggestionsTab:Input({
    Flag = "suggestion",
    Type = "Textarea",
    Placeholder = "Enter your suggestion...",
    Callback = function(input)
        inputText = input
    end
})

suggestionsTab:Button({
    Title = "Send â¶",
    
    Locked = false,
    Callback = function()
        if cooldown then
            WindUI:Notify({
                Title = "Please Wait",
                Content = "You're sending messages too fast! Wait a few seconds.",
                Duration = 4
            })
            return
        end

        if inputText == "" then
            WindUI:Notify({
                Title = "Empty Suggestion",
                Content = "Please write something before sending.",
                Duration = 4
            })
            return
        end

        cooldown = true
        task.delay(cooldownTime, function() cooldown = false end)

        local player = game:GetService("Players").LocalPlayer
        local data = {
            ["username"] = "Suggestion System",
            ["embeds"] = {{
                ["title"] = "ð¡ New Suggestion Received",
                ["color"] = 3447003,
                ["fields"] = {
                    {["name"] = "Player", ["value"] = player.Name, ["inline"] = false},
                    {["name"] = "Suggestion", ["value"] = inputText, ["inline"] = false},
                    {["name"] = "Game", ["value"] = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name, ["inline"] = false},
                },
                ["footer"] = {["text"] = os.date("!%Y-%m-%d %H:%M:%S UTC")}
            }}
        }

        local jsonData = HttpService:JSONEncode(data)

        local success, response = pcall(function()
            return request({
                Url = WEBHOOK_URL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        end)

        if success then
            WindUI:Popup({
                Title = "Thanks!",
                Icon = "badge-check",
                Content = "Your suggestion has been sent successfully!",
                Buttons = {{
                    Title = "Continue",
                    Icon = "arrow-right",
                    Callback = function() end,
                    Variant = "Primary",
                }}
            })
            suggestionInput:Set("")
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to send suggestion. Please try again later.",
                Duration = 5
            })
        end
    end
})

local SS           = EnsureTab("Server",    { Title = "Server Settings", Icon = "chart-no-axes-gantt",        Locked = false })

Window:Divider()


-- === Farming Egg Bookmark Helpers (injected) ===
_G.FarmingEggPosition = _G.FarmingEggPosition or nil

local function SetFarmingEggHere()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    _G.FarmingEggPosition = hrp.Position
    if WindUI and WindUI.Notify then
        WindUI:Notify({
            Title = "Rcash Hub",
            Content = ("Farming Egg set at (%.2f, %.2f, %.2f)"):format(
                _G.FarmingEggPosition.X, _G.FarmingEggPosition.Y, _G.FarmingEggPosition.Z
            ),
            Duration = 4,
            Icon = "map-pin",
        })
    end
end

local function TeleportToFarmingEgg()
    if not _G.FarmingEggPosition then
        if WindUI and WindUI.Notify then
            WindUI:Notify({
                Title = "Rcash Hub",
                Content = "No Farming Egg saved yet. Use âSet Farming Eggâ first.",
                Duration = 4,
                Icon = "map-pin-off",
            })
        end
        return
    end
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    hrp.CFrame = CFrame.new(_G.FarmingEggPosition + Vector3.new(0, 3, 0))
    if WindUI and WindUI.Notify then
        WindUI:Notify({
            Title = "Rcash Hub",
            Content = "Teleported to Farming Egg.",
            Duration = 3,
            Icon = "navigation",
        })
    end
end
-- === /Farming Egg Bookmark Helpers ===


  -- visual divider between Server and Farm

local FarmTab      = EnsureTab("Farm",      { Title = "Auto Farming",    Icon = "dollar-sign",                Locked = false })
local MinigamesTab = EnsureTab("Minigames", { Title = "Minigames",       Icon = "gamepad-2",                  Locked = false })
local PetsTab      = EnsureTab("Pets",      { Title = "Pets",            Icon = "paw-print",                  Locked = false })
local HatchTab     = EnsureTab("Hatching",  { Title = "Hatching",        Icon = "egg",                        Locked = false })
local RiftsTab     = EnsureTab("Rifts",     { Title = "Rifts",           Icon = "sparkles",                   Locked = false })
local PotionsTab   = EnsureTab("Potions",   { Title = "Potions",         Icon = "flask-conical",              Locked = false })
local ShrineTab    = EnsureTab("Shrines",   { Title = "Shrines",         Icon = "gift",                       Locked = false })
local ShopsTab     = EnsureTab("Shops",     { Title = "Shops",           Icon = "shopping-bag",               Locked = false })
local HalloweenTab = EnsureTab("Halloween", { Title = "Halloween",       Icon = "between-horizontal-start",   Locked = false })
local MiscTab      = EnsureTab("Misc",      { Title = "Misc",            Icon = "plus",                       Locked = false })
    
-- === Buff Tracker (Misc â "Buffs") ===
do
    if not _G.__BUFFS_TRACKER_UI__ then
        _G.__BUFFS_TRACKER_UI__ = true

        local Players     = game:GetService("Players")
        local RunService  = game:GetService("RunService")
        local LocalPlayer = Players.LocalPlayer

        -- state
        _G.TrackBuffs = _G.TrackBuffs == nil and true or _G.TrackBuffs
        local hbConn, lastTick = nil, 0
        local EXCLUDE = { Shiny = true, MilestoneBuff = true }

        -- tiny utils
        local function safeText(lbl)
            return (lbl and lbl:IsA("TextLabel") and lbl.Text) and tostring(lbl.Text) or ""
        end

        local ROMAN = {I=1, V=5, X=10, L=50, C=100, D=500, M=1000}
        local function romanToInt(s)
            s = tostring(s or ""):upper():gsub("[^IVXLCDM]","")
            if s == "" then return nil end
            local n, i = 0, 1
            while i <= #s do
                local a = ROMAN[s:sub(i,i)] or 0
                local b = ROMAN[s:sub(i+1,i+1)] or 0
                if a < b then n = n + (b - a); i = i + 2 else n = n + a; i = i + 1 end
            end
            return n
        end

        local function isActiveFrame(frame)
            if not (frame and frame:IsA("GuiObject")) then return false end
            if not frame.Visible then return false end
            -- Be safe: if any ancestor is hidden, treat as inactive.
            local p = frame.Parent
            while p and p ~= LocalPlayer do
                if p:IsA("GuiObject") and p.Visible == false then return false end
                p = p.Parent
            end
            return true
        end

        local function getBuffsFolder()
            local pg = LocalPlayer:FindFirstChild("PlayerGui")
            local sg = pg and pg:FindFirstChild("ScreenGui")
            return sg and sg:FindFirstChild("Buffs") or nil
        end

        local function collectActiveBuffLines()
            local buffFolder = getBuffsFolder()
            if not buffFolder then return {} end

            local lines = {}
            for _, child in ipairs(buffFolder:GetChildren()) do
                -- skip exclusions
                if EXCLUDE[child.Name] then
                    continue
                end
                -- frame must be visible/active
                if not isActiveFrame(child) then
                    continue
                end

                local button = child:FindFirstChild("Button")
                local name   = tostring(child.Name or "?")

                local label  = button and button:FindFirstChild("Label")
                local amount = button and button:FindFirstChild("Amount")
                local level  = button and button:FindFirstChild("Level")

                local levelTxt = safeText(level)
                local levelNum = romanToInt(levelTxt)
                local levelPart = (levelNum and (" Lv " .. levelNum) or (levelTxt ~= "" and (" Lv " .. levelTxt) or ""))

                local body = ""
                if amount and safeText(amount) ~= "" then
                    body = safeText(amount)
                elseif label and safeText(label) ~= "" then
                    body = safeText(label)
                else
                    -- no known text holders; try any TextLabel under button as a fallback
                    if button then
                        for _, d in ipairs(button:GetDescendants()) do
                            if d:IsA("TextLabel") and d.Visible and (d.Name == "Time" or d.Name == "Value" or d.Name == "Text" or d.Name == "Amount") then
                                body = safeText(d)
                                if body ~= "" then break end
                            end
                        end
                    end
                end

                -- Only display if we actually found something meaningful
                if body ~= "" or levelPart ~= "" then
                    table.insert(lines, ("- %s: %s%s"):format(name, body ~= "" and body or "Active", levelPart))
                end
            end

            table.sort(lines, function(a,b) return a:lower() < b:lower() end)
            return lines
        end

        -- UI
        local sectionHeader = MiscTab:Paragraph({
            Title = "Buffs",
            Desc = "Live view of your active buffs from PlayerGui.ScreenGui.Buffs."
        })

        local buffsParagraph = MiscTab:Paragraph({
            Title = "Active Buffs",
            Desc = "Scanning..."
        })

        local function renderOnce()
            local lines = {}
            local ok, res = pcall(collectActiveBuffLines)
            if ok and type(res) == "table" and #res > 0 then
                lines = res
                if buffsParagraph and buffsParagraph.SetDesc then buffsParagraph:SetDesc(table.concat(lines, "\n")) end
            else
                if buffsParagraph and buffsParagraph.SetDesc then buffsParagraph:SetDesc("No active buffs found.") end
            end
        end

        local trackToggle = MiscTab:Toggle({
        Flag = "TrackBuffs",
        Title = "Track Buffs",
            Value = _G.TrackBuffs,
            Callback = function(v)
                _G.TrackBuffs = v
                if v then
                    -- start / resume
                    if hbConn then hbConn:Disconnect() hbConn = nil end
                    hbConn = RunService.Heartbeat:Connect(function()
                        local t = os.clock()
                        if (t - (lastTick or 0)) >= 1.0 then
                            lastTick = t
                            renderOnce()
                        end
                    end)
                    renderOnce()
                else
                    if hbConn then hbConn:Disconnect() hbConn = nil end
                end
            end
        })

        -- one-shot initial state
        if _G.TrackBuffs then
            if hbConn then hbConn:Disconnect() hbConn = nil end
            hbConn = RunService.Heartbeat:Connect(function()
                local t = os.clock()
                if (t - (lastTick or 0)) >= 1.0 then
                    lastTick = t
                    renderOnce()
                end
            end)
            renderOnce()
        else
            renderOnce()
        end
    end
end
-- === /Buff Tracker ===

    


Window:Divider()

local SettingsTab  = EnsureTab("Settings",  { Title = "Settings",        Icon = "settings",                   Locked = false })

-- === Webhooks Tab (Hatch Notifier) ===
-- Single-run guard to prevent duplicate UI/heartbeat on re-execution
_G.__RCASH_WEBHOOKS_UI__ = _G.__RCASH_WEBHOOKS_UI__ or false
do
    if _G.__RCASH_WEBHOOKS_UI__ then
        if _G.__RCASH_WEBHOOKS_HB__ and typeof(_G.__RCASH_WEBHOOKS_HB__) == "RBXScriptConnection" then
            pcall(function() _G.__RCASH_WEBHOOKS_HB__:Disconnect() end)
        end
    else
        _G.__RCASH_WEBHOOKS_UI__ = true

        local WebhooksTab = EnsureTab("Webhooks", { Title = "Webhooks", Icon = "link", Locked = false })

        -- Services
        local Players     = game:GetService("Players")
        local RunService  = game:GetService("RunService")
        local HttpService = game:GetService("HttpService")
        local player      = Players.LocalPlayer

        -- Compatible request function
        local request = http_request or request or (syn and syn.request) or (fluxus and fluxus.request) or (http and http.request)

        -- Config
        local PUBLIC_WEBHOOK_URL   = "https://discord.com/api/webhooks/1434229641219936398/eyBsuGT3bkUvm4mjmi8qgJZPmYmRaqNCg9fZUiLA7DJxU_VsIstvC8wPI1VyhyvJkk0n"
        local WEBHOOK_URL          = "" -- user can set a private URL via the input
        
        local GATE_MYTHIC_BY_ODDS = true
        local MIN_MYTHIC_CHANCE   = 2000000000 -- 1 in X (default = 2B like your other script)
local ENABLE_DISCORD_PING  = false
        local DISCORD_USER_ID      = ""

        -- State
        local recentFrames = {}

        -- Helpers
        local function isRecentFrame(frame)
            local id = tostring(frame)
            local now = os.clock()
            local last = recentFrames[id]
            if last and (now - last) < 5 then
                return true
            end
            recentFrames[id] = now
            return false
        end

        
        local function getChanceValue(chanceText)
            if not chanceText then return nil end
            -- Accept formats like "1 in 2,000,000,000"
            local x = tostring(chanceText):match("[Ii][Nn]%s*([%d,]+)")
            if not x then return nil end
            x = x:gsub(",", "")
            local n = tonumber(x)
            return n
        end
local function sendWebhook(name, rarity, shiny, chance)
            if not request then return end

            -- require chance to look like "1 in X" if provided, avoids false positives
            if chance and not string.find(chance, " in ", 1, true) then
                return
            end

            -- Collect stats for embed
            local totalHatches = "N/A"
            local leaderstats = player:FindFirstChild("leaderstats")
            if leaderstats then
                local hatches = leaderstats:FindFirstChild("ð¥ Hatches")
                if hatches and hatches:IsA("IntValue") then
                    totalHatches = tostring(hatches.Value)
                end
            end

            -- Optional mention
            local mention = ""
            local id = (DISCORD_USER_ID or ""):gsub("%s", "")
            if ENABLE_DISCORD_PING and id ~= "" and #id > 10 then
                mention = "<@" .. id .. ">"
            end

            -- Image + naming based on shiny/mythic/secret
            local imageBase    = (name or ""):gsub("%s+", "_"):lower()
            local rarityLower  = (rarity or ""):lower()
            local shinyBool    = not not shiny
            local authorName, title, thumbnailURL
            local iconURL = "https://img.files.cheap/u/TvQtay.webp"

            if shinyBool and rarityLower:find("mythic") then
                authorName   = "You've hatched a Shiny Mythic: " .. (rarity or "Mythic")
                title        = "Shiny Mythic " .. (name or "?")
                thumbnailURL = "https://content.bgsi.io/shiny_mythic_" .. imageBase .. ".webp"
            elseif rarityLower:find("mythic") then
                authorName   = "You've hatched a Mythic: " .. (rarity or "Mythic")
                title        = "Mythic " .. (name or "?")
                thumbnailURL = "https://content.bgsi.io/mythic_" .. imageBase .. ".webp"
            elseif shinyBool then
                authorName   = "You've hatched a Shiny: " .. (rarity or "")
                title        = "Shiny " .. (name or "?")
                thumbnailURL = "https://content.bgsi.io/shiny_" .. imageBase .. ".webp"
            else
                authorName   = "You've hatched a: " .. (rarity or "?")
                title        = name or "?"
                thumbnailURL = "https://content.bgsi.io/" .. imageBase .. ".webp"
            end

            local desc = string.format(
                "ð²  __**Chance**__: %s\nð£ __**Hatch Date**__: <t:%d:R>\nð¥  __**Hatches**__: %s\nðµï¸  __**Hatched By**__: %s",
                chance or "N/A",
                os.time(),
                totalHatches,
                player.Name
            )

            local data = {
                ["username"] = "Hatch Webhook",
                ["avatar_url"] = "https://cdn.discordapp.com/attachments/1422944023999549510/1429984163070611557/logorcash..png?ex=69074948&is=6905f7c8&hm=6bc3bce62bed21a4dfe19a11fe6a85d0c89cacee55af6d1f6b87461a5304eaba",
                ["content"] = mention,
                ["embeds"] = {{
                    ["author"] = { ["name"] = authorName, ["icon_url"] = iconURL },
                    ["color"] = 15761628,
                    ["thumbnail"] = { ["url"] = thumbnailURL },
                    ["title"] = title,
                    ["description"] = desc,
                    ["fields"] = {},
                    ["footer"] = { ["text"] = "By Rcash HUB" }
                }}
            }

            local jsonPayload = HttpService:JSONEncode(data)

            -- Send to both Public and Private (if set)
            local endpoints = {}
            if PUBLIC_WEBHOOK_URL and #PUBLIC_WEBHOOK_URL > 0 then
                table.insert(endpoints, PUBLIC_WEBHOOK_URL)
            end
            if WEBHOOK_URL and WEBHOOK_URL ~= "" and WEBHOOK_URL ~= PUBLIC_WEBHOOK_URL then
                table.insert(endpoints, WEBHOOK_URL)
            end
            if #endpoints == 0 then
                return -- nothing to send to
            end

            local anyOk = false
            for _, url in ipairs(endpoints) do
                local ok, response = pcall(function()
                    return request({
                        Url = url,
                        Method = "POST",
                        Headers = { ["Content-Type"] = "application/json" },
                        Body = jsonPayload
                    })
                end)
                local status = response and response.StatusCode
                if ok and status and (status == 204 or status == 200) then
                    anyOk = true
                end
            end

            if not anyOk then
                WindUI:Notify({ Title = "HATCH WEBHOOK FAILED", Content = "Failed to send pet notification.", Duration = 4, Icon = "x" })
            else
                WindUI:Notify({ Title = "HATCH WEBHOOK SENT", Content = "Notification dispatched for " .. (name or "?"), Duration = 3, Icon = "check-circle" })
            end
        end

        local function handleFrame(frame, name, rarity, shiny, deleted, chanceText)
            local rarityLower = (rarity or ""):lower()
            local isTargetRarity = rarityLower:find("secret") or rarityLower:find("mythic") or rarityLower:find("infinity")
            -- Mythic gate: require chance >= MIN_MYTHIC_CHANCE when enabled
            if GATE_MYTHIC_BY_ODDS and rarityLower:find("mythic") then
                local num = getChanceValue(chanceText)
                if not num or num < MIN_MYTHIC_CHANCE then isTargetRarity = false end
            end
            if isTargetRarity and not rarityLower:find("legendary") and not deleted and not isRecentFrame(frame) then
                WindUI:Notify({ Title = string.upper(rarity or "?") .. " HATCH", Content = "Detected " .. ((shiny and "Shiny ") or "") .. (name or "?") .. " via GUI.", Duration = 3, Icon = "egg" })
                sendWebhook(name, rarity, shiny, chanceText)
            end
        end

        local function monitorHatch()
            local gui = player:FindFirstChild("PlayerGui")
            gui = gui and gui:FindFirstChild("ScreenGui")
            if not gui then return end

            -- Hatching frame(s)
            local hatch = gui:FindFirstChild("Hatching")
            if hatch then
                for _, frame in ipairs(hatch:GetChildren()) do
                    if frame:IsA("Frame") and frame:FindFirstChild("Label") and frame:FindFirstChild("Rarity") then
                        local name    = frame.Label.Text
                        local rarity  = frame.Rarity.Text
                        local shiny   = frame:FindFirstChild("Shiny")   and frame.Shiny.Visible or false
                        local deleted = frame:FindFirstChild("Deleted") and frame.Deleted.Visible or false
                        local chance  = frame:FindFirstChild("Chance")  and frame.Chance.Text or nil
                        handleFrame(frame, name, rarity, shiny, deleted, chance)
                    end
                end
            end

            -- Template path (fallback)
            local template = gui:FindFirstChild("Template")
            if template then
                for _, obj in ipairs(template:GetDescendants()) do
                    if obj:IsA("TextLabel") and obj.Name == "Rarity" and obj.Visible then
                        local frame   = obj.Parent
                        local name    = frame and frame:FindFirstChild("Label") and frame.Label.Text or "Unknown"
                        local chance  = frame and frame:FindFirstChild("Chance") and frame.Chance.Text or "N/A"
                        local shiny   = frame and frame:FindFirstChild("Shiny") and frame.Shiny.Visible or false
                        local deleted = frame and frame:FindFirstChild("Deleted") and frame.Deleted.Visible or false
                        handleFrame(obj, name, obj.Text, shiny, deleted, chance)
                    end
                end
            end
        end

        -- Always-on: ensure single Heartbeat connection
        if _G.__RCASH_WEBHOOKS_HB__ and typeof(_G.__RCASH_WEBHOOKS_HB__) == "RBXScriptConnection" then
            pcall(function() _G.__RCASH_WEBHOOKS_HB__:Disconnect() end)
        end
        _G.__RCASH_WEBHOOKS_HB__ = RunService.Heartbeat:Connect(monitorHatch)

        -- Inputs
        WebhooksTab:Input({
        Flag = "DiscordWebhookURL",
        Title = "Discord Webhook URL",
            Value = "",
            Type = "Input",
            Placeholder = "Blank = send to Public; If set = send to BOTH",
            Callback = function(url)
                WEBHOOK_URL = (url or ""):gsub("%s+", "")
                if WEBHOOK_URL == "" then
                    WindUI:Notify({ Title = "Webhook", Content = "Using Public webhook only.", Duration = 3 })
                else
                    WindUI:Notify({ Title = "Webhook", Content = "Private webhook saved. Will send to BOTH.", Duration = 3 })
                end
            end
        })

        WebhooksTab:Toggle({
        Flag = "EnableDiscordPing",
        Title = "Enable Discord Ping",
            Value = ENABLE_DISCORD_PING,
            Callback = function(value)
                ENABLE_DISCORD_PING = value
                WindUI:Notify({ Title = "Ping Status", Content = "Discord ping is now " .. (value and "enabled" or "disabled") .. ".", Duration = 3 })
            end
        })

        WebhooksTab:Input({
        Flag = "DiscordUserID",
        Title = "Your Discord User ID",
            Value = DISCORD_USER_ID,
            Type = "Input",
            Placeholder = "e.g., 123456789012345678",
            Callback = function(id)
                DISCORD_USER_ID = (id or ""):gsub("%s", "")
                WindUI:Notify({ Title = "User ID Set", Content = "Discord User ID has been saved.", Duration = 3 })
            end
        })

        -- Friendly toast to confirm load
        WindUI:Notify({ Title = "GUI Notifier Loaded", Content = "Monitoring BGS GUI for Secret/Mythic/Infinity (Non-Legendary) variants.", Duration = 7, Icon = "egg" })
    end
end
-- === /Webhooks Tab ===

-- <<< END: Tab order prelude <<

-- == BEGIN: Auto Shops Tab-- == BEGIN: Auto Shops Tab (appended) ==
do
    local ShopsTab = _G.__Tabs.Shops

    local ReplicatedStorage = ReplicatedStorage or game:GetService("ReplicatedStorage")
    local RemoteEvent = RemoteEvent or (ReplicatedStorage and ReplicatedStorage.Shared and ReplicatedStorage.Shared.Framework and ReplicatedStorage.Shared.Framework.Network and ReplicatedStorage.Shared.Framework.Network.Remote and ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent)
    if not RemoteEvent then
        pcall(function()
            RemoteEvent = game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.RemoteEvent
        end)
    end

    local SHOPS = {
        { internal = "shard-shop",         display = "Blackmarket",        slots = 3 },
        { internal = "alien-shop",         display = "Alien Shop",         slots = 3 },
        { internal = "dice-shop",          display = "Dice Merchant",      slots = 3 },
        { internal = "festival-shop",      display = "Festival Shop",      slots = 3 },
        { internal = "fishing-shop",       display = "Fishing Shop",       slots = 3 },
        { internal = "traveling-merchant", display = "Traveling Merchant", slots = 3 },
        { internal = "spooky-shop",        display = "Spooky Shop",        slots = 3 },
        { internal = "halloween-shop",     display = "Halloween Shop",     slots = 6 },
        { internal = "dark-shop",          display = "Dark Shop",          slots = 6 },
        { internal = "temp-shop",          display = "Test Shop",          slots = 3 },
    }

    local displayList, displayToInternal = {}, {}
    for _, s in ipairs(SHOPS) do
        displayToInternal[s.display] = s.internal
        table.insert(displayList, s.display)
    end

    local Config = {
        AutoRun = false,
        EnabledShops = {},
        Delay = 1.0,
    }
    for _, shop in ipairs(displayList) do
        Config.EnabledShops[shop] = true
    end

    local function safeWait(t)
        task.wait((t and t > 0) and t or 0.5)
    end

    local function purchaseFromShop(displayName)
        local internal = displayToInternal[displayName]
        if not internal then return end

        local slots
        for _, s in ipairs(SHOPS) do
            if s.display == displayName then slots = s.slots break end
        end
        if not slots then slots = 3 end

        for slot = 1, slots do
            if RemoteEvent then
                pcall(function()
                    RemoteEvent:FireServer("BuyShopItem", internal, slot, true)
                end)
            end
            safeWait(Config.Delay)
        end
    end

    local Section = ShopsTab:Section({
        Title = "Auto Shop",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })

    Section:Paragraph({
        Title = "Auto Purchase",
        Desc = "Buys every slot from selected shops"
    })

    Section:Divider()

    Section:Dropdown({
        Flag = "ShopsToBuyFrom",
        Title = "Shops to Buy From",
        Values = displayList,
        Multi = true,
        Value = displayList,
        Callback = function(selected)
            local map = {}
            for _, n in ipairs(selected) do map[n] = true end
            for _, n in ipairs(displayList) do
                Config.EnabledShops[n] = not not map[n]
            end
            WindUI:Notify({ Title = "Shops Updated", Content = "Selection saved.", Duration = 3 })
        end
    })

    Section:Slider({
        Flag = "DelayBetweenPurchasesS",
        Title = "Delay Between Purchases (s)",
        Step = 0.1,
        Value = { Min = 0.1, Max = 5, Default = Config.Delay },
        Callback = function(v)
            Config.Delay = v
        end
    })

    local Running = false

    local function mainLoop()
        if Running then return end
        Running = true
        while Config.AutoRun do
            for _, name in ipairs(displayList) do
                if Config.EnabledShops[name] then
                    pcall(function() purchaseFromShop(name) end)
                end
            end
            task.wait(3)
        end
        Running = false
    end

    Section:Toggle({
        Flag = "AutoPurchase",
        Title = "Auto Purchase",
        Value = Config.AutoRun,
        Callback = function(state)
            Config.AutoRun = state
            if state then
                WindUI:Notify({ Title = "Shops", Content = "Auto Purchase ON", Duration = 3 })
                task.spawn(mainLoop)
            else
                WindUI:Notify({ Title = "Shops", Content = "Auto Purchase OFF", Duration = 3 })
            end
        end
    })

    Section:Button({
        Title = "Buy Selected Shops Once",
        
        Icon = "",
        Callback = function()
            for _, name in ipairs(displayList) do
                if Config.EnabledShops[name] then
                    task.spawn(function() pcall(function() purchaseFromShop(name) end) end)
                end
            end
            WindUI:Notify({ Title = "Shops", Content = "Purchase attempts sent.", Duration = 3 })
        end
    })

    

-- == BEGIN: Competitive Tab (merged from Competitive.txt) ==
do
    -- Services / locals (scoped to this block to avoid conflicts)
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local LocalPlayer = Players.LocalPlayer
    local RemoteEvent = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent

    -- Create the tab in the existing Window
    local CompetitiveTab = Window:Tab({
        Title = "Competitive",
        Icon = "trophy",
        Locked = false
    })

    -- Sections
    local AutoSection = CompetitiveTab:Section({ Title = "Automation", TextXAlignment = "Left", TextSize = 17, Opened = false })
    local EggSection  = CompetitiveTab:Section({ Title = "Egg Preferences", TextXAlignment = "Left", TextSize = 17, Opened = false })

    -- Egg positions (ported from Competitive.txt)
    local compEggPositions = {
        ["Common Egg"]   = Vector3.new(-83.86, 10.11, 1.57),
        ["Spotted Egg"]  = Vector3.new(-93.96, 10.11, 7.41),
        ["Iceshard Egg"] = Vector3.new(-117.06, 10.11, 7.74),
        ["Spikey Egg"]   = Vector3.new(-124.58, 10.11, 4.58),
        ["Magma Egg"]    = Vector3.new(-133.02, 10.11, -1.55),
        ["Crystal Egg"]  = Vector3.new(-140.20, 10.11, -8.36),
        ["Lunar Egg"]    = Vector3.new(-143.85, 10.11, -15.93),
        ["Void Egg"]     = Vector3.new(-145.91, 10.11, -26.13),
        ["Hell Egg"]     = Vector3.new(-145.17, 10.11, -36.78),
        ["Rainbow Egg"]  = Vector3.new(-134.49, 10.11, -52.36),
        ["Mining Egg"]   = Vector3.new(-120.00, 10.00, -64.00),
        ["Cyber Egg"]    = Vector3.new(-95.00, 10.00, -63.00),
        ["Infinity Egg"] = Vector3.new(-99.00, 9.00, -26.00),
        ["Neon Egg"]     = Vector3.new(-83.00, 10.00, -57.00),
        ["Icy Egg"]      = Vector3.new(-60.00, 13.00, -2.00),
        ["Vine Egg"]     = Vector3.new(-65.00, 13.00, 7.00),
        ["Lava Egg"]     = Vector3.new(-72.00, 13.00, 15.00),
        ["Atlantis Egg"] = Vector3.new(-82.00, 13.00, 21.00),
        ["Classic Egg"]  = Vector3.new(-91.00, 13.00, 24.00)
    }

    -- Quest definitions (ported from Competitive.txt)
    local compQuests = {
        {ID="Hatch200",        DisplayName="Hatch 200 Eggs",        Pattern="200",       DefaultEgg=""},
        {ID="Hatch350",        DisplayName="Hatch 350 Eggs",        Pattern="350",       DefaultEgg=""},
        {ID="Hatch450",        DisplayName="Hatch 450 Eggs",        Pattern="450",       DefaultEgg=""},
        {ID="Hatch950",        DisplayName="Hatch 950 Eggs",        Pattern="950",       DefaultEgg=""},
        {ID="Hatch1250",       DisplayName="Hatch 1250 Eggs",       Pattern="1250",      DefaultEgg=""},
        {ID="HatchCommon",     DisplayName="Hatch Common Pets",     Pattern="common",    DefaultEgg=""},
        {ID="HatchUnique",     DisplayName="Hatch Unique Pets",     Pattern="unique",    DefaultEgg=""},
        {ID="HatchRare",       DisplayName="Hatch Rare Pets",       Pattern="rare",      DefaultEgg=""},
        {ID="HatchEpic",       DisplayName="Hatch Epic Pets",       Pattern="epic",      DefaultEgg=""},
        {ID="HatchLegendary",  DisplayName="Hatch Legendary Pets",  Pattern="legendary", DefaultEgg=""},
        {ID="HatchMythic",     DisplayName="Hatch Mythic Pets",     Pattern="mythic",    DefaultEgg=""},
        {ID="HatchShiny",      DisplayName="Hatch Shiny Pets",      Pattern="shiny",     DefaultEgg=""},
    }


    -- State
    local compSelectedQuests = {}
    local compDontSkipMining = { Value = true }
    local compNoTwoShiny     = { Value = true }
    local compAutomation     = false

    -- Helpers
    local function compGetHRP()
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        return character:WaitForChild("HumanoidRootPart")
    end

    local function compTeleportToPosition(position)
        local hrp = compGetHRP()
        if (hrp.Position - position).Magnitude > 5 then
            hrp.CFrame = CFrame.new(position)
            task.wait(0.2)
        end
    end

    local function compHatchEgg(eggName)
        local pos = compEggPositions[eggName]
        if pos then compTeleportToPosition(pos) end
    end

    -- Core loop (ported and scoped)
    local function compTaskManager()
        while compAutomation do
            local ok, err = pcall(function()
                local tasksFolder = LocalPlayer.PlayerGui:WaitForChild("ScreenGui")
                    :WaitForChild("Competitive"):WaitForChild("Frame")
                    :WaitForChild("Content"):WaitForChild("Tasks")

                -- Gather the repeatable task slots (3 & 4)
                local templates = {}
                for _, f in ipairs(tasksFolder:GetChildren()) do
                    if f:IsA("Frame") and f.Name == "Template" then
                        table.insert(templates, f)
                    end
                end
                table.sort(templates, function(a, b) return a.LayoutOrder < b.LayoutOrder end)

                local repeatableTasks = {}
                for i, frame in ipairs(templates) do
                    if i == 3 or i == 4 then
                        local content = frame:FindFirstChild("Content")
                        local titleLabel = content and content:FindFirstChild("Label")
                        local typeLabel  = content and content:FindFirstChild("Type")
                        if titleLabel and typeLabel then
                            table.insert(repeatableTasks, {
                                frame = frame,
                                title = titleLabel.Text,
                                type  = typeLabel.Text,
                                slot  = i
                            })
                        end
                    end
                end

                local protectedSlots = {}
                local highestPriorityAction = nil
                local hasFoundFirstShiny = false

                for _, questData in ipairs(compQuests) do
                    if table.find(compSelectedQuests, questData.DisplayName) then
                        for _, task in ipairs(repeatableTasks) do
                            local lowerTitle = task.title:lower()
                            if task.type == "Repeatable" and lowerTitle:find(questData.Pattern, 1, true) then
                                local isShiny = questData.Pattern == "shiny"
                                if isShiny and compNoTwoShiny.Value and hasFoundFirstShiny then
                                    -- Skip second shiny task if toggled
                                else
                                    protectedSlots[task.slot] = true
                                    if isShiny then hasFoundFirstShiny = true end

                                    if not highestPriorityAction then
                                        local matchedEgg
                                        for eggName in pairs(compEggPositions) do
                                            if lowerTitle:find(eggName:lower():gsub(" egg", ""), 1, true) then
                                                matchedEgg = eggName
                                                break
                                            end
                                        end
                                        local eggToHatch = matchedEgg or questData.DefaultEgg
                                        highestPriorityAction = { egg = eggToHatch, title = task.title }
                                    end
                                end
                            end
                        end
                    end
                end

                -- "Don't Skip Mining Egg 200" safety
                if compDontSkipMining.Value then
                    for _, task in ipairs(repeatableTasks) do
                        local lowerTitle = task.title:lower()
                        if task.type == "Repeatable" and lowerTitle:find("mining egg") and lowerTitle:find("200") then
                            protectedSlots[task.slot] = true
                        end
                    end
                end

                -- Take action: teleport to egg
                if highestPriorityAction then
                    compHatchEgg(highestPriorityAction.egg)
                end

                -- Reroll everything not protected
                for _, task in ipairs(repeatableTasks) do
                    if task.type == "Repeatable" and not protectedSlots[task.slot] then
                        RemoteEvent:FireServer("CompetitiveReroll", task.slot)
                        task.wait(0.3)
                    end
                end
            end)

            if not ok then warn("[Rcash Hub][Competitive] Error:", err) end
            task.wait(0.5)
        end
    end

    -- Build UI
    local eggNames = {}
    for name in pairs(compEggPositions) do table.insert(eggNames, name) end
    table.sort(eggNames)

    AutoSection:Paragraph({
        Title = "Automation Control",
        Desc  = "Enable automatic competitive quest handling and egg hatching."
    })

    AutoSection:Toggle({
        Flag = "AutoCompleteQuests",
        Title = "Auto Complete Quests",
        Icon  = "cpu",
        Value = false,
        Callback = function(v)
            compAutomation = v
            getgenv().autoPressE = v
            if v then
                task.spawn(compTaskManager)
                task.spawn(function()
                    while getgenv().autoPressE do
                        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                        task.wait()
                        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                        task.wait()
                    end
                end)
            end
        end
    })

    local questNames = {}
    for _, q in ipairs(compQuests) do table.insert(questNames, q.DisplayName) end

    AutoSection:Dropdown({
        Flag = "SelectQuestsToComplete",
        Title   = "Select Quests to Complete",
        Values  = questNames,
        Multi   = true,
        Callback = function(v)
            compSelectedQuests = v
        end
    })

    AutoSection:Toggle({
        Flag = "NoTwoShinyTasks",
        Title = "No Two Shiny Tasks",
        Icon  = "sparkles",
        Value = true,
        Callback = function(v)
            compNoTwoShiny.Value = v
        end
    })

    -- AutoSection:Toggle({
        -- Flag = "ProtectMiningEgg200",
    --     Title = "Protect 'Mining Egg 200'",
    --     Icon  = "shield",
    --     Value = compDontSkipMining.Value,
    --     _G.__RiftHunterToggle = riftHunterToggle
        -- Callback = function(v) compDontSkipMining.Value = v end
    -- })

    EggSection:Paragraph({
        Title = "Egg Preferences",
        Desc  = "Set preferred eggs for each quest type below."
    })

    for _, q in ipairs(compQuests) do
        EggSection:Dropdown({
            Flag = "FlagAuto",
            Title   = q.DisplayName,
            Values  = eggNames,
            Value   = q.DefaultEgg,
        Callback = function(v) q.DefaultEgg = v end
        })
    end

    WindUI:Notify({
        Title = "Rcash Hub",
        Content = "Competitive Tab loaded successfully.",
        Duration = 5
    })
end
end

do
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")

    local okLocalData, LocalData = pcall(function() return require(ReplicatedStorage.Client.Framework.Services.LocalData) end)
    if not okLocalData then LocalData = nil end
    local okFishingAreas, FishingAreas = pcall(function() return require(ReplicatedStorage.Shared.Data.FishingAreas) end)
    if not okFishingAreas then FishingAreas = nil end
    local okAutoFish, AutoFish = pcall(function() return require(ReplicatedStorage.Client.Gui.Frames.Fishing.FishingWorldAutoFish) end)
    if not okAutoFish then AutoFish = nil end

    local ok, FishingUtil = pcall(function() return require(ReplicatedStorage.Shared.Utils.FishingUtil) end)
    if ok and FishingUtil then
        FishingUtil.BASE_REEL_SPEED = 9999
        FishingUtil.GetReelSpeed = function(_, _, _) return 9999 end
    end

    -- Location/teleport data
    local LOCATION_DATA = {
        ["Fisher's Island"]   = { FishingCFrame = CFrame.new(-23622, 9, -159) },
        ["Blizzard Hills"]    = { FishingCFrame = CFrame.new(-21412, 8, -101001) },
        ["Poison Jungle"]     = { FishingCFrame = CFrame.new(-19282, 8, 18681) },
        ["Infernite Volcano"] = { FishingCFrame = CFrame.new(-17223,10,-20487) },
        ["Lost Atlantis"]     = { FishingCFrame = CFrame.new(-13867,10,-20446) },
        ["Dream Island"]      = { FishingCFrame = CFrame.new(-21797, 9,-20603) },
        ["Classic Island"]    = { FishingCFrame = CFrame.new(-41505,10,-20593) },
    }

    local function equipRod()
        pcall(function()
            ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent:FireServer("EquipRod")
        end)
    end
    local function unequipRod()
        pcall(function()
            ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent:FireServer("UnequipRod")
        end)
    end

    local equipThread
    local automationEnabled = false
    local lastEquippedTarget

    local function startEquipLoop()
        if equipThread then return end
        equipThread = task.spawn(function()
            while automationEnabled do
                equipRod()
                task.wait(3)
            end
            equipThread = nil
        end)
    end

    local function teleportToLocation(name)
        local data = LOCATION_DATA[name]
        if not data or not data.FishingCFrame then return end
        local dest = data.FishingCFrame
        local radius = 10
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp and (hrp.Position - dest.Position).Magnitude <= radius then return dest end
        local conn
        conn = RunService.Heartbeat:Connect(function()
            local ch = LocalPlayer.Character
            if ch and ch:FindFirstChild("HumanoidRootPart") then
                ch.HumanoidRootPart.CFrame = dest
            end
        end)
        task.delay(2, function() if conn and conn.Connected then conn:Disconnect() end end)
        return dest
    end

    local function waitUntilArrived(dest, radius, timeout)
        radius, timeout = radius or 10, timeout or 6
        local t0 = tick()
        while tick() - t0 < timeout do
            local ch = LocalPlayer.Character
            if ch and ch:FindFirstChild("HumanoidRootPart") then
                if (ch.HumanoidRootPart.Position - dest.Position).Magnitude <= radius then return true end
            end
            RunService.Heartbeat:Wait()
        end
        return false
    end

    local function readyAndStart(dest, key)
        if not dest then return end
        if waitUntilArrived(dest, 12, 8) then
            equipRod()
            lastEquippedTarget = key
        end
    end

    local AREA_NAME_ALIAS = {
        starter="Fisher's Island", blizzard="Blizzard Hills", jungle="Poison Jungle",
        lava="Infernite Volcano", atlantis="Lost Atlantis", dream="Dream Island", classic="Classic Island"
    }
    local function resolveAreaName(name) return AREA_NAME_ALIAS[name] or name end
    local function getHighestIsland()
        local all={"Fisher's Island","Blizzard Hills","Poison Jungle","Infernite Volcano","Lost Atlantis","Dream Island","Classic Island"}
        return all[#all] or all[1]
    end

    -- UI: place controls under the existing Auto Farming tab (FarmTab)
    local FishingSection = FarmTab:Section({
        Title = "Auto Fishing",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })

    local currentMode, selectedZone = "Leveling", "Fisher's Island"
    local statusParagraph = FishingSection:Paragraph({ Title = "Status", Desc = "Idle" })
    local function updateStatus(t) statusParagraph:SetDesc(t) end

    FishingSection:Dropdown({
        Flag = "FishingMode",
        Title="Fishing Mode",
        Values={"Leveling","Quest","Index","Specific Zone"},
        Value=currentMode,
        Callback=function(v)
            currentMode=v
            WindUI:Notify({Title="Mode",Content="Set mode â "..v,Duration=3})
            lastEquippedTarget=nil
        end
    })

    FishingSection:Dropdown({
        Flag = "SelectZone",
        Title="Select Zone",
        Values={"Fisher's Island","Blizzard Hills","Poison Jungle","Infernite Volcano","Lost Atlantis","Dream Island","Classic Island"},
        Value=selectedZone,
        Callback=function(v)
            selectedZone=v
            WindUI:Notify({Title="Zone",Content="Selected zone â "..v,Duration=3})
        end
    })

    FishingSection:Dropdown({
        Flag = "ManualTeleport",
        Title="Manual Teleport",
        Values={"Fisher's Island","Blizzard Hills","Poison Jungle","Infernite Volcano","Lost Atlantis","Dream Island","Classic Island"},
        Callback=function(v)
            local dest=teleportToLocation(v)
            updateStatus("Manual â "..v)
            if automationEnabled then readyAndStart(dest,v) end
        end
    })

    -- AutoFish Protection & Toggle override
    if AutoFish and AutoFish.Toggle then
        local originalToggle = AutoFish.Toggle
        AutoFish.Toggle = function(self, ...)
            if automationEnabled and self.Enabled then
                
                return
            end
            return originalToggle(self, ...)
        end
    end

    FishingSection:Toggle({
        Flag = "EnableAutoFishing",
      Title = "Enable Auto Fishing",
      Value = false,
      Callback = function(state)
        automationEnabled = state
        if state then
          WindUI:Notify({
            Title = "Fishing Manager",
            Content = "Teleporting to correct area before enabling...",
            Duration = 4
          })

          -- figure out initial destination
          local targetName
          if currentMode == "Specific Zone" then
            targetName = selectedZone
          elseif currentMode == "Leveling" then
            targetName = getHighestIsland()
          elseif currentMode == "Quest" then
            local hud = playerGui:FindFirstChild("ScreenGui")
              and playerGui.ScreenGui:FindFirstChild("QuestHUDTask")
            if hud and hud.Visible then
              local text = hud.Content.Info.Task.Text
              local locRaw = text:match("in (.+)")
              targetName = resolveAreaName(locRaw or "Fisher's Island")
            end
          end
          targetName = targetName or "Fisher's Island"

          local dest = teleportToLocation(targetName)
          updateStatus("Teleporting â " .. targetName)

          -- Wait for arrival then enable
          task.spawn(function()
            if waitUntilArrived(dest, 12, 8) then
              updateStatus("Arrived â Equipping rod...")
              startEquipLoop()
              equipRod()

              -- Wait for AutoFish to be ready
              local ready, t0 = false, tick()
              repeat
                task.wait(0.5)
                if AutoFish and AutoFish.Toggle then
                  ready = true
                end
              until ready or tick() - t0 > 8

              if ready then
                local success = false
                for _ = 1, 6 do
                  task.wait(0.5)
                  if AutoFish and AutoFish.Toggle and not AutoFish.Enabled then
                    AutoFish:Toggle(true)
                    success = true
                    break
                  elseif AutoFish and AutoFish.Enabled then
                    success = true
                    break
                  end
                end

                if success then
                  
                  updateStatus("Fishing at " .. targetName)
                  WindUI:Notify({
                    Title = "Fishing Manager",
                    Content = "Arrived and Auto-Fish enabled!",
                    Duration = 3
                  })
                else
                  
                  updateStatus("Arrived but Auto-Fish not active.")
                  WindUI:Notify({
                    Title = "Fishing Manager",
                    Content = "Rod equipped but Auto-Fish not ready (retry manually).",
                    Duration = 4
                  })
                end
              else
                
                updateStatus("Auto-Fish module not found after arrival.")
                WindUI:Notify({
                  Title = "Fishing Manager",
                  Content = "Auto-Fish not detected â maybe rejoin or re-enable later.",
                  Duration = 4
                })
              end
            else
              updateStatus("Teleport failed / timed out")
              WindUI:Notify({
                Title = "Fishing Manager",
                Content = "Teleport failed or timed out â Auto-Fish not started.",
                Duration = 4
              })
              automationEnabled = false
            end
          end)

        else
          local AF = require(game:GetService("ReplicatedStorage").Client.Gui.Frames.Fishing.FishingWorldAutoFish)
          pcall(function() AF:Toggle(false) end)
          unequipRod()
          WindUI:Notify({
            Title = "Fishing Manager",
            Content = "Automation Disabled (Rod unequipped, AutoFish off)",
            Duration = 3
          })
          updateStatus("Idle")
        end
      end
    })

    -- Main loop
    local function doModeStep()
        if not automationEnabled then return end
        equipRod()
        if currentMode=="Leveling" then
            local t=getHighestIsland()
            updateStatus("Leveling â "..t)
            local d=teleportToLocation(t)
            readyAndStart(d,t)
        elseif currentMode=="Quest" then
            local hud=playerGui:FindFirstChild("ScreenGui") and playerGui.ScreenGui:FindFirstChild("QuestHUDTask")
            if hud and hud.Visible then
                local text=hud.Content.Info.Task.Text
                local locRaw=text:match("in (.+)")
                local t=resolveAreaName(locRaw or "Fisher's Island")
                if not LOCATION_DATA[t] then t="Fisher's Island" end
                updateStatus("Quest â "..t)
                local d=teleportToLocation(t)
                readyAndStart(d,t)
            else
                local t="Fisher's Island"
                updateStatus("Quest â none visible, defaulting to "..t)
                local d=teleportToLocation(t)
                readyAndStart(d,t)
            end
        elseif currentMode=="Specific Zone" then
            local t=selectedZone or "Fisher's Island"
            updateStatus("Custom Zone â "..t)
            local d=teleportToLocation(t)
            readyAndStart(d,t)
        else
            local data=LocalData and LocalData.Get and LocalData:Get() or nil
            if data and data.CollectedFish then
                local target
                if FishingAreas then
                    for name,area in pairs(FishingAreas) do
                        for _,fish in ipairs(area.Pool) do
                            if not data.CollectedFish[fish.Item] then target=resolveAreaName(name) break end
                        end
                        if target then break end
                    end
                end
                if target then
                    updateStatus("Index â "..target)
                    local d=teleportToLocation(target)
                    readyAndStart(d,target)
                else updateStatus("All fish collected!") end
            end
        end
    end

    task.spawn(function()
        while true do
            task.wait(5)
            doModeStep()
        end
    end)

    
end
-- == END: Fishing Manager ==

    


-- == BEGIN: Potions Tab (merged from Potions.txt) ==
do
local PotionsTab = _G.__Tabs.Potions

--== Config ==--
local Config = {
	PotionsToCraft = {"Coins","Lucky","Mythic"},
	SkipIngredientTiers = {},
	AutoCraft = false,
	CraftDelay = 1,

	UsePotions = {},
	UseTiers = {"1"},
	AutoUse = false,
	UseDelay = 1,
	UseLimit = 100
}

local usedCount = {}

--== Sections (aligned with reference script) ==--
local CraftSec = PotionsTab:Section({
	Title = "Crafting Settings",
	TextXAlignment = "Left",
	TextSize = 17,
	Opened = false,
})

local UseSec = PotionsTab:Section({
	Title = "Potion Usage Settings",
	TextXAlignment = "Left",
	TextSize = 17,
	Opened = false,
})

--== UI: Crafting (inside Section) ==--
CraftSec:Dropdown({
    Flag = "PotionsToCraft",
	Title = "Potions to Craft",
	Values = {"Coins","Mythic","Lucky","Speed","Tickets"},
	Multi = true,
	Value = Config.PotionsToCraft,
	Callback = function(sel) Config.PotionsToCraft = sel end
})

CraftSec:Dropdown({
    Flag = "TiersToNotUse",
	Title = "Tiers to Not Use",
	Values = {"1","2","3","4"},
	Multi = true,
	Value = {},
	Callback = function(sel)
		local out = {}
		for _,v in ipairs(sel) do table.insert(out, tonumber(v)) end
		Config.SkipIngredientTiers = out
	end
})

CraftSec:Toggle({
    Flag = "AutoCraftPotions",
	Title = "Auto Craft Potions",
	Value = false,
	Callback = function(state)
		Config.AutoCraft = state
		WindUI:Notify({ Title="Rcash Hub", Content=state and "Auto crafting ON" or "Auto crafting OFF", Duration=3 })
	end
})

--== UI: Usage (inside Section) ==--
UseSec:Dropdown({
    Flag = "PotionsToUse",
	Title = "Potions to Use",
	Values = {
		"Coins","Mythic","Lucky","Speed","Tickets",
		"Secret Elixir","Egg Elixir","Infinity Elixir",
		"Halloween Elixir","Halloween Infinity Elixir"
	},
	Multi = true,
	Value = {},
	Callback = function(sel) Config.UsePotions = sel end
})

UseSec:Dropdown({
    Flag = "PotionTiersToUse",
	Title = "Potion Tiers to Use",
	Values = {"1","2","3","4","5","6","7"},
	Multi = true,
	Value = {"1"},
	Callback = function(sel)
		Config.UseTiers = sel
	end
})

UseSec:Input({
    Flag = "UseAmountPerPotion",
	Title = "Use Amount Per Potion",
	Placeholder = "Enter number, e.g. 5",
	Default = tostring(Config.UseLimit),
	Callback = function(value)
		local n = tonumber(value)
		if not n or n < 1 then
			return WindUI:Notify({ Title="Invalid Input", Content="Please enter a positive number.", Duration=3 })
		end
		Config.UseLimit = math.floor(n)
		WindUI:Notify({ Title="Rcash Hub", Content="Use limit per potion set to "..Config.UseLimit, Duration=3 })
	end
})

UseSec:Toggle({
    Flag = "AutoUseSelectedPotions",
	Title = "Auto Use Selected Potions",
	Value = false,
	Callback = function(state)
		Config.AutoUse = state
		usedCount = {}
		WindUI:Notify({ Title="Rcash Hub", Content=state and "Auto use ON" or "Auto use OFF", Duration=3 })
	end
})

--== Services ==--
--== Helper Functions ==--
local function safeWait(t)
	task.wait(t and t > 0 and t or 0.3)
end

local function useInChunks(potionName, level, owned, remainingLimit, nameKey)
	local sent = 0
	local function send(n)
		RemoteEvent:FireServer("UsePotion", potionName, level, n)
		sent += n
		usedCount[nameKey] = (usedCount[nameKey] or 0) + n
		
		safeWait(Config.UseDelay)
	end

	while sent < remainingLimit and owned > 0 do
		local left = remainingLimit - sent
		if left <= 0 then break end

		local n
		if left >= 10 and owned >= 10 then
			n = 10
		elseif left >= 5 and owned >= 5 then
			n = 5
		else
			n = 1
		end
		if n > left then n = left end

		send(n)
		owned -= n

		if usedCount[nameKey] >= Config.UseLimit then
			
			break
		end
	end

	return sent
end

--== Core Potion Logic ==--
local function CraftOnce()
	for _, pName in ipairs(Config.PotionsToCraft) do
		for tier = 2, 5 do
			local ingredientTier = tier - 1
			if table.find(Config.SkipIngredientTiers, ingredientTier) then
				continue
			end
			RemoteEvent:FireServer("CraftPotion", pName, tier, true)
			safeWait(0.3)
		end
	end
end

local function UseSelectedPotions()
	local data = LocalData:Get()
	if not (data and data.Potions) then return end

	local allDone = true

	for _, name in ipairs(Config.UsePotions) do
		usedCount[name] = usedCount[name] or 0

		-- Skip if already reached the limit
		if usedCount[name] >= Config.UseLimit then
			
			continue
		end

		local potionFound = false

		for _, pd in pairs(data.Potions) do
			if pd.Name == name and pd.Amount > 0 then
				potionFound = true
				allDone = false
				local remaining = Config.UseLimit - usedCount[name]

				if remaining <= 0 then
					break
				end

				if name == "Halloween Elixir" then
					-- Only use levels that are selected in UI
					if table.find(Config.UseTiers, tostring(pd.Level)) then
						local level = math.clamp(pd.Level or 1, 1, 5)
						useInChunks("Halloween Elixir", level, pd.Amount, remaining, name)
					end

				elseif name == "Secret Elixir" or name == "Egg Elixir" or name == "Infinity Elixir" or name == "Halloween Infinity Elixir" then
					-- These behave as tier 1 only
					useInChunks(name, 1, pd.Amount, remaining, name)

				else
					-- Standard potions check tiers
					if table.find(Config.UseTiers, tostring(pd.Level)) then
						useInChunks(pd.Name, pd.Level, pd.Amount, remaining, name)
					end
				end
			end
		end

		if not potionFound then
			
		end
	end

	if allDone then
		Config.AutoUse = false
		WindUI:Notify({
			Title = "Rcash Hub",
			Content = "â All selected potions have reached their use limits or are unavailable.",
			Duration = 5
		})
	end
end


--== Loops ==--
task.spawn(function()
	while task.wait(Config.CraftDelay) do
		if Config.AutoCraft then
			pcall(CraftOnce)
		end
	end
end)

task.spawn(function()
	while task.wait(math.max(Config.UseDelay, 0.05)) do
		if Config.AutoUse then
			pcall(UseSelectedPotions)
		end
	end
end)
end
-- == END: Potions Tab ==

local AllEnchants = {
        "Bubbler I","Bubbler II","Bubbler III","Bubbler IV","Bubbler V",
        "Gleaming I","Gleaming II","Gleaming III",
        "Looter I","Looter II","Looter III","Looter IV","Looter V",
        "Team Up I","Team Up II","Team Up III","Team Up IV","Team Up V",
        "High Roller","Infinity","Magnetism","Secret Hunter","Ultra Roller","Determination","Shiny Seeker"
    }

    local enchantLookup = {}

    -- If no roman level is present, treat level as nil (wildcard) so it matches any level during detection.
    local function parseEnchantName(name)
        if type(name) ~= "string" then
            name = tostring(name)
        end
        local romanMap = { I = 1, II = 2, III = 3, IV = 4, V = 5 }
        local baseName, roman = name:match("^(.*) (%S+)$")
        local level = romanMap and romanMap[roman]
        if baseName and level then
            return { id = baseName:lower():gsub(" ", "-"), level = level }
        else
            return { id = name:lower():gsub(" ", "-"), level = nil } -- <-- wildcard level
        end
    end

    -- Build name lookup with a fallback (_any) for un-leveled display names
    for _, fullName in ipairs(AllEnchants) do
        local parsed = parseEnchantName(fullName)
        enchantLookup[parsed.id] = enchantLookup[parsed.id] or {}
        if parsed.level then
            enchantLookup[parsed.id][parsed.level] = fullName
        else
            enchantLookup[parsed.id]._any = fullName
        end
    end

    -- === Pet data access ===
    local function getPetDataById(petId)
        local pd = LocalData:Get()
        if not (pd and pd.Pets) then return nil end
        for _, pet in pairs(pd.Pets) do
            if pet.Id == petId then return pet end
        end
        return nil
    end

    local function getEquippedPetsForDisplay()
        local petsForDisplay = {}
        local pd = LocalData:Get()
        if not (pd and pd.TeamEquipped and pd.Teams and pd.Pets) then return petsForDisplay end
        local teamId = pd.TeamEquipped
        local teamInfo = pd.Teams[teamId]
        if not (teamInfo and teamInfo.Pets) then return petsForDisplay end

        for _, petId in ipairs(teamInfo.Pets) do
            local petInfo = getPetDataById(petId)
            if petInfo then
                local nameParts = {}
                if petInfo.Shiny then table.insert(nameParts, "Shiny") end
                if petInfo.Mythic then table.insert(nameParts, "Mythic") end
                table.insert(nameParts, petInfo.Name or "Unknown Pet")
                if petInfo.Enchants and next(petInfo.Enchants) then
                    local enchantNames = {}
                    for _, enchantData in pairs(petInfo.Enchants) do
                        local dict = enchantLookup[enchantData.Id]
                        local fullName = dict and ((enchantData.Level and dict[enchantData.Level]) or dict._any)
                        table.insert(enchantNames, fullName or enchantData.Id)
                    end
                    table.insert(nameParts, "(" .. table.concat(enchantNames, ", ") .. ")")
                end
                table.insert(petsForDisplay, { name = table.concat(nameParts, " "), id = petId })
            end
        end
        return petsForDisplay
    end

    -- Helper to test if current enchant matches a target (wildcard level supported)
    local function enchantMatches(currentEnchant, target)
        if not currentEnchant or not target then return false end
        if currentEnchant.Id ~= target.id then return false end
        if target.level == nil then return true end -- wildcard
        return currentEnchant.Level == target.level
    end

    local function findEnchantSlot(petInfo, targetEnchants, specificSlot)
        if not petInfo or not petInfo.Enchants then return nil, nil end

        if specificSlot then
            local idx = tonumber(specificSlot) or specificSlot
            local currentEnchant = petInfo.Enchants[idx]
            if currentEnchant then
                for _, target in ipairs(targetEnchants) do
                    if enchantMatches(currentEnchant, target) then
                        local dict = enchantLookup[currentEnchant.Id]
                        local fullName = dict and ((currentEnchant.Level and dict[currentEnchant.Level]) or dict._any)
                        return fullName or currentEnchant.Id, tonumber(idx) or idx
                    end
                end
            end
        else
            for slotKey, currentEnchant in pairs(petInfo.Enchants) do
                for _, target in ipairs(targetEnchants) do
                    if enchantMatches(currentEnchant, target) then
                        local dict = enchantLookup[currentEnchant.Id]
                        local fullName = dict and ((currentEnchant.Level and dict[currentEnchant.Level]) or dict._any)
                        return fullName or currentEnchant.Id, tonumber(slotKey) or slotKey
                    end
                end
            end
        end
        return nil, nil
    end

    local PetsTab = _G.__Tabs.Pets

    -- === Wrap all controls in a Section (aligned with your reference script) ===
    local RerollSection = PetsTab:Section({
        Title = "Reroll Controls",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })
    local MiscSection = PetsTab:Section({
        Title = "Misc Stuff",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })

    local CurrencyData = {
        "Coins",
        "Gems",
        "Tickets",
        "Seashells",
        "FestivalCoins",
        "Pearls",
        "Leaves",
    }
    table.insert(CurrencyData, 1, "Candycorn")

    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local player = Players.LocalPlayer


    local RemoteEvent = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent
    local LocalData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
    local PetsModule = require(ReplicatedStorage.Shared.Data.Pets) 

    local MAX_TEAM_SIZE = 8
    local autoEquipEnabled = false
    local selectedCurrency = "Candycorn"

    local function getPetInfo(pet)
        local info = PetsModule[pet.Name]
        if not info or not info.Stats then return nil end
        return info
    end

    local function getSortedPets(currencyKey)
        local data = LocalData:Get()
        if not data or not data.Pets then return {} end
        local pets = {}
        for _, pet in pairs(data.Pets) do
            local info = getPetInfo(pet)
            if info and info.Stats and info.Stats[currencyKey] then
                table.insert(pets, {
                    Id = pet.Id,
                    Name = pet.Name,
                    StatValue = info.Stats[currencyKey],
                    Stats = info.Stats
                })
            end
        end
        table.sort(pets, function(a, b)
            return a.StatValue > b.StatValue
        end)
        return pets
    end

    local function getEquippedTeam()
        local data = LocalData:Get()
        if not data then return {} end
        local equipped = {}
        if data.Teams and data.TeamEquipped then
            local team = data.Teams[data.TeamEquipped]
            if team and team.Pets then
                for _, id in ipairs(team.Pets) do
                    equipped[id] = true
                end
            end
        end
        return equipped
    end

    local function autoEquipTask()
        while autoEquipEnabled do
            local data = LocalData:Get()
            if not data or not data.Pets then task.wait(5) continue end

            local sorted = getSortedPets(selectedCurrency)
            if #sorted == 0 then task.wait(5) continue end

            local equipped = getEquippedTeam()

            local desired = {}
            for i = 1, math.min(MAX_TEAM_SIZE, #sorted) do
                desired[sorted[i].Id] = sorted[i]
            end

            local changesMade = false

            for id in pairs(equipped) do
                if not desired[id] then
                    RemoteEvent:FireServer("UnequipPet", id)
                    task.wait(0.15)
                    changesMade = true
                end
            end

            local currentlyEquipped = 0
            for id in pairs(equipped) do
                currentlyEquipped += 1
            end

            for id, pet in pairs(desired) do
                if not equipped[id] and currentlyEquipped < MAX_TEAM_SIZE then
                    RemoteEvent:FireServer("EquipPet", id)
                    task.wait(0.15)
                    currentlyEquipped += 1
                    changesMade = true
                end
            end
        
            if changesMade then
            task.wait(1) 
            else
                task.wait(5)
            end
        end
    end

    local equipTask = nil

    MiscSection:Dropdown({
        Flag = "CurrencyToAutoEquip",
        Title = "Currency To Auto Equip",
        Description = "Select the pet stat to prioritize for auto-equipping.",
        Values = CurrencyData,
        Default = "Candycorn",
        Multi = false,
        Callback = function(value)
            selectedCurrency = value
            WindUI:Notify({
                Title = "Auto Equip",
                Content = "Sorting currency set to: " .. selectedCurrency,
                Duration = 3
            })
        end
    })

    MiscSection:Toggle({
        Flag = "AutoEquipByBestPetStat",
        Title = "Auto Equip By Best Pet Stat",
        Description = "Automatically equips your " .. MAX_TEAM_SIZE .. " best pets for the selected stat.",
        Value = false,
        Callback = function(Value)
            autoEquipEnabled = Value
            if Value then
                WindUI:Notify({
                    Title = "Auto Equip",
                    Content = "Auto Equip Enabled for: " .. selectedCurrency,
                    Duration = 3
                })
                equipTask = task.spawn(autoEquipTask)
            elseif equipTask then
                WindUI:Notify({
                    Title = "Auto Equip",
                    Content = "Auto Equip Disabled.",
                    Duration = 3
                })
                ask.cancel(equipTask)
                equipTask = nil
            end
        end
    })

    -- === State ===
    local isRerolling = false
    local selectedPets, selectedPrimary, selectedSecondary = {}, {}, {}
    local rerollSpeed = 0.1 -- allow LocalData to update after rerolls
    local equippedPetsForDisplay = getEquippedPetsForDisplay()
    local selectedItem = "Gems"
    local autoSwitch = false

    -- Helpers for UI set calls
    local function setDropdownValue(drop, val)
        if drop and drop.Set then
            drop:Set(val)
        elseif drop and drop.SetValue then
            drop:SetValue(val)
        end
    end
    local function setToggleValue(tgl, val)
        if tgl and tgl.Set then
            tgl:Set(val)
        elseif tgl and tgl.SetValue then
            tgl:SetValue(val)
        elseif tgl and tgl.Select then
            tgl:Select(val)
        end
    end

    -- === Widgets (created under the Section) ===
    local PetDropdown = RerollSection:Dropdown({
        Flag = "Pet",
        Title = "Pets to Reroll",
        Values = (function()
            local n = {}
            for _, v in ipairs(equippedPetsForDisplay) do
                table.insert(n, v.name)
            end
            return n
        end)(),
        Multi = true,
        Callback = function(values)
            selectedPets = values or {}
        end
    })

    local PrimaryDropdown = RerollSection:Dropdown({
        Flag = "Primary",
        Title = "Primary Enchants",
        Desc = "Reroll both slots for these enchants.",
        Values = AllEnchants,
        Multi = true,
        Callback = function(values)
            selectedPrimary = values or {}
        end
    })

    local SecondaryDropdown = RerollSection:Dropdown({
        Flag = "Secondary",
        Title = "Secondary Enchants",
        Desc = "After primary found, reroll other slot for these (Shiny pets only).",
        Values = AllEnchants,
        Multi = true,
        Callback = function(values)
            selectedSecondary = values or {}
        end
    })

    local ItemToUse = RerollSection:Dropdown({
        Flag = "ItemToUse",
        Title = "Select What To Use",
        Values = {"Gems", "Orbs", "Shadow Crystals"},
        Callback = function(value)
            selectedItem = value
        end
    })

    local SwitchRR = RerollSection:Toggle({
        Flag = "SwitchRR",
        Title = "Switch To Reroll Orb When Out Of Gems",
        Value = false,
        Callback = function(value)
            autoSwitch = value
        end
    })

    local RerollToggle = RerollSection:Toggle({
        Flag = "Reroll",
        Title = "Start / Stop Rerolling",
        Value = false,
        Callback = function(value)
            isRerolling = value
            if not isRerolling then
                WindUI:Notify({ Title = "Stopped", Content = "Rerolling stopped.", Duration = 3 })
                return
            end

            task.spawn(function()
                local targetPetIds, primaryTargets, secondaryTargets = {}, {}, {}
                local currentPetList = getEquippedPetsForDisplay()

                local function isDict(tbl)
                    for k, _ in pairs(tbl) do
                        if type(k) ~= "number" then return true end
                    end
                    return false
                end

                if next(selectedPets) then
                    if isDict(selectedPets) then
                        for _, petData in ipairs(currentPetList) do
                            if selectedPets[petData.name] then
                                table.insert(targetPetIds, petData.id)
                            end
                        end
                    else
                        for _, petName in ipairs(selectedPets) do
                            for _, petData in ipairs(currentPetList) do
                                if petData.name == petName then
                                    table.insert(targetPetIds, petData.id)
                                end
                            end
                        end
                    end
                end

                -- Primary enchants
                if next(selectedPrimary) then
                    if isDict(selectedPrimary) then
                        for name, sel in pairs(selectedPrimary) do
                            if sel then table.insert(primaryTargets, parseEnchantName(name)) end
                        end
                    else
                        for _, name in ipairs(selectedPrimary) do
                            table.insert(primaryTargets, parseEnchantName(name))
                        end
                    end
                end

                -- Secondary enchants
                if next(selectedSecondary) then
                    if isDict(selectedSecondary) then
                        for name, sel in pairs(selectedSecondary) do
                            if sel then table.insert(secondaryTargets, parseEnchantName(name)) end
                        end
                    else
                        for _, name in ipairs(selectedSecondary) do
                            table.insert(secondaryTargets, parseEnchantName(name))
                        end
                    end
                end

                -- Validation
                if #targetPetIds == 0 then
                    WindUI:Notify({ Title = "Error", Content = "No pets selected to reroll.", Duration = 5 })
                    setToggleValue(RerollToggle, false)
                    isRerolling = false
                    return
                end
                if #primaryTargets == 0 then
                    WindUI:Notify({ Title = "Error", Content = "No primary enchants selected.", Duration = 5 })
                    setToggleValue(RerollToggle, false)
                    isRerolling = false
                    return
                end
                if #secondaryTargets > 0 and selectedItem ~= "Gems" then
                    WindUI:Notify({ Title = "Error", Content = "Secondary enchants only supported when using Gems.", Duration = 5 })
                    setToggleValue(RerollToggle, false)
                    isRerolling = false
                    return
                end

                -- === Loop ===
                for _, petId in ipairs(targetPetIds) do
                    if not isRerolling then break end

                    local prettyName
                    for _, p in ipairs(currentPetList) do
                        if p.id == petId then
                            prettyName = p.name
                            break
                        end
                    end
                    WindUI:Notify({ Title = "Now Targeting", Content = "Focusing on: " .. (prettyName or "Unknown"), Duration = 3 })

                    local petDone = false
                    while not petDone and isRerolling do
                        local currentPetData = getPetDataById(petId)
                        if not currentPetData then break end

                        local primaryName, primarySlot = findEnchantSlot(currentPetData, primaryTargets)
                        if primaryName then
                            if #secondaryTargets == 0 then
                                WindUI:Notify({ Title = "Success!", Content = (prettyName or "Pet") .. " got " .. primaryName .. ".", Duration = 5 })
                                petDone = true
                                break
                            end

                            if not currentPetData.Shiny then
                                WindUI:Notify({ Title = "Skipping", Content = "Secondary rerolling only works for Shiny pets.", Duration = 5 })
                                petDone = true
                                break
                            end

                            local otherSlot = (primarySlot == 1) and 2 or 1
                            local secondaryName = select(1, findEnchantSlot(currentPetData, secondaryTargets, otherSlot))

                            if secondaryName then
                                WindUI:Notify({ Title = "Success!", Content = (prettyName or "Pet") .. " now has " .. primaryName .. " & " .. secondaryName .. "!", Duration = 6 })
                                petDone = true
                                break
                            else
                                -- Chase secondary: reroll only the other slot
                                RemoteEvent:FireServer("RerollEnchant", currentPetData.Id, otherSlot)
                                task.wait(math.max(rerollSpeed, 0.2)) -- allow server state -> LocalData propagation
                            end
                        else
                            -- No primary yet: do a general reroll using the selected item
                            local success = true
                            if selectedItem == "Shadow Crystals" then
                                RemoteEvent:FireServer("UseShadowCrystal", currentPetData.Id)
                                task.wait(math.max(rerollSpeed, 0.2))
                            else
                                success = RemoteFunction:InvokeServer("RerollEnchants", currentPetData.Id, selectedItem)
                            end

                            if not success then
                                if autoSwitch and selectedItem == "Gems" then
                                    selectedItem = "Orbs"
                                    setDropdownValue(ItemToUse, "Orbs")
                                    WindUI:Notify({ Title = "Switched", Content = "Out of Gems, switched to Orbs.", Duration = 5 })
                                else
                                    WindUI:Notify({ Title = "Error", Content = "Insufficient " .. selectedItem .. ". Stopping.", Duration = 5 })
                                    setToggleValue(RerollToggle, false)
                                    isRerolling = false
                                    return
                                end
                            end
                        end

                        task.wait(math.max(rerollSpeed, 0.2))
                    end
                end

                if isRerolling then
                    WindUI:Notify({ Title = "Complete!", Content = "All selected pets processed.", Duration = 5 })
                    setToggleValue(RerollToggle, false)
                    isRerolling = false
                end
            end)
        end
    })

    -- === Optimized: refresh "Pets to Reroll" only when equipped pets change ===
    local function __teamSignature()
        local ok, data = pcall(function() return LocalData:Get() end)
        if not ok or not data then return "" end
        local teamId = data.TeamEquipped
        local team = data.Teams and data.Teams[teamId]
        if not (team and team.Pets and data.Pets) then return "" end

        -- Build a compact signature of the equipped team + pet enchants
        local parts = { tostring(teamId) }
        for _, petId in ipairs(team.Pets) do
            table.insert(parts, tostring(petId))
            local p = data.Pets[petId]
            if p and p.Enchants then
                for _, e in pairs(p.Enchants) do
                    table.insert(parts, ("%s:%s"):format(e.Id, e.Level))
                end
            end
        end
        return table.concat(parts, "|")
    end

    local function __refreshPetDropdown()
        if not (PetDropdown and PetDropdown.Refresh) then return end
        local list = getEquippedPetsForDisplay()
        local names = {}
        for _, v in ipairs(list) do names[#names+1] = v.name end
        PetDropdown:Refresh(names)
    end

    local __lastTeamSig = nil
    local function __refreshIfChanged()
        local sig = __teamSignature()
        if sig ~= __lastTeamSig then
            __lastTeamSig = sig
            __refreshPetDropdown()
        end
    end

    -- Try to react to relevant remote updates (if the game broadcasts them)
    do
        local ok, remote = pcall(function()
            return ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent
        end)
        if ok and remote and remote.OnClientEvent then
            remote.OnClientEvent:Connect(function(name)
                if name == "EquipTeam" or name == "EquipPet" or name == "UnequipPet"
                or name == "RerollEnchant" or name == "RerollEnchants"
                or name == "UpdateEnchants" then
                    task.defer(__refreshIfChanged)
                end
            end)
        end
    end

    -- Lightweight safety net: very rare check (cheap) in case we missed an event
    task.spawn(function()
        while not WindUI.Unloaded do
            __refreshIfChanged()
            task.wait(3) -- infrequent; does nothing if team didn't change
        end
    end)

    -- initial fill
    __refreshIfChanged()


    local HatchTab = _G.__Tabs.Hatching

    local MiscTab = _G.__Tabs.Misc

    local CE = _G.__Tabs.Halloween


-- == BEGIN: Current Event (merged) ==
do
    local EventTab = CE
----------------------------------------------------------
-- Section A: Auto Halloween Upgrades (from your base) --
----------------------------------------------------------
local AutoHalloweenUpgrades = false
local function AutoBuyHalloweenUpgrades()
    local remote = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent
    while AutoHalloweenUpgrades do
        remote:FireServer("BuyHalloweenUpgrade", "Currency")
        remote:FireServer("BuyHalloweenUpgrade", "Luck")
        remote:FireServer("BuyHalloweenUpgrade", "SecretLuck")
        remote:FireServer("BuyHalloweenUpgrade", "InfinityLuck")
        task.wait(10)
    end
end

local UpgradesSection = EventTab:Section({ Title = "Upgrades", TextXAlignment = "Left", TextSize = 17, Opened = false })

UpgradesSection:Toggle({
    Flag = "HWU",
    Title = "Auto Halloween Upgrades",
    Value = false,
    Callback = function(value)
        AutoHalloweenUpgrades = value
        if value then task.spawn(AutoBuyHalloweenUpgrades) end
    end
})

UpgradesSection:Toggle({
    Flag = "AST",
    Title = "Auto Spooky Track Reward Claim",
    Value = false,
    Callback = function(value)
        _G.AutoSpookyTrack = value
        if value then 
            task.spawn(AutoSpookyTrack) 
        end
    end
})

-----------------------------------------------
-- Section B: Egg Teleport (from Egg TP)     --
-----------------------------------------------
-- State
local ETP_ENABLED = false
local etp_connections = {}
local etp_lastTarget = nil


-- remembers if we paused Rift Hunter
local ETP_RiftHunterWasOn = ETP_RiftHunterWasOn or false
-- UI
local EggTP = EventTab:Section({ Title = "Egg Teleport", TextXAlignment = "Left", TextSize = 17, Opened = false })
local ETPStatus = EggTP:Paragraph({ Title = "Status", Desc = "Disabled." })

local function etpSetStatus(t)
    if ETPStatus and ETPStatus.SetDesc then ETPStatus:SetDesc(t) end
end

local function getHRP()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    return char:FindFirstChild("HumanoidRootPart")
end

local function getModelCFrame(model)
    if model.PrimaryPart then return model.PrimaryPart.CFrame end
    local cf = model:GetBoundingBox()
    return cf
end

local function safeCF(target)
    local baseCF
    if target:IsA("BasePart") then baseCF = target.CFrame
    elseif target:IsA("Model") then baseCF = getModelCFrame(target) end
    return baseCF and (baseCF * CFrame.new(0, 5, 0)) or nil
end

local function findEggPlatformSpawn()
    local summoned = Workspace:FindFirstChild("SummonedEgg")
    if not summoned then return nil end

    local direct = summoned:FindFirstChild("EggPlatformSpawn")
    if direct and (direct:IsA("BasePart") or direct:IsA("Model")) then return direct end

    for _, d in ipairs(summoned:GetDescendants()) do
        if d.Name == "EggPlatformSpawn" and (d:IsA("BasePart") or d:IsA("Model")) then
            return d
        end
    end
    return nil
end

local function teleportToEggPlatform()
    local target = findEggPlatformSpawn()
    if not target then etpSetStatus("Status: No EggPlatformSpawn."); return end
    
    if etp_lastTarget == target then
        local hrp2 = getHRP()
        local dest2 = safeCF(target)
        if hrp2 and dest2 then
            local delta = (hrp2.Position - dest2.Position).Magnitude
            if delta > 10 then
                -- re-teleport if we drifted away from the platform even if it's the same one
                hrp2.CFrame = dest2
                etpSetStatus("Status: Re-teleported (same platform).")
            else
                etpSetStatus("Status: Already at latest platform.")
            end
        else
            etpSetStatus("Status: Character not ready or invalid platform.")
        end
        return
    end

    local hrp = getHRP()
    if not hrp then etpSetStatus("Status: Character not ready."); return end

    local dest = safeCF(target)
    if not dest then etpSetStatus("Status: Invalid platform CFrame."); return end

    -- Pause Rift Hunter once per active egg if it was on
    if not ETP_RiftHunterWasOn and (__RiftHunterEnabled == true) then
        ETP_RiftHunterWasOn = true
        pcall(SetRiftHunterEnabled, false)
    end

    hrp.CFrame = dest
    etp_lastTarget = target
    etpSetStatus("Status: Teleported.")
end

local function etpDisconnectAll()
    for _, cn in ipairs(etp_connections) do
        pcall(function() cn:Disconnect() end)
    end
    table.clear(etp_connections)
end

local function onSummonedEgg(egg)
    table.insert(etp_connections, egg.DescendantAdded:Connect(function(desc)
        if ETP_ENABLED and desc.Name == "EggPlatformSpawn" and (desc:IsA("BasePart") or desc:IsA("Model")) then
            teleportToEggPlatform()
        end
    end))

    -- When the summoned egg is removed, resume Rift Hunter if we paused it
    table.insert(etp_connections, egg.AncestryChanged:Connect(function(obj, parent)
        if obj == egg and parent == nil then
            if ETP_ENABLED and ETP_RiftHunterWasOn then
                pcall(SetRiftHunterEnabled, true)
            end
            pcall(function() if _G.__StartRiftHunterLoop then _G.__StartRiftHunterLoop() end end)
            ETP_RiftHunterWasOn = false
            etp_lastTarget = nil
            etpSetStatus("Status: Egg cleared. (RH restored if it was paused.)")
        end
    end))

    if ETP_ENABLED then task.defer(teleportToEggPlatform) end
end

local function etpArmWatchers()
    table.insert(etp_connections, Workspace.ChildAdded:Connect(function(child)
        if ETP_ENABLED and child.Name == "SummonedEgg" then
            onSummonedEgg(child)
            task.defer(teleportToEggPlatform)
        end
    end))
    local existing = Workspace:FindFirstChild("SummonedEgg")
    if existing then onSummonedEgg(existing) end
end

EggTP:Toggle({
    Flag = "AUTO_EGG_TP",
    Title = "Auto Teleport to Egg",
    Value = false,
        Callback = function(v)
        ETP_ENABLED = v
        etp_lastTarget = nil
        if v then
            etpSetStatus("Status: Enabled. Watchingâ¦")
            etpArmWatchers()
            task.defer(teleportToEggPlatform)
        else
            etpSetStatus("Status: Disabled.")
            etpDisconnectAll()
            -- if we had paused RH, restore it when user disables Egg TP
            if ETP_RiftHunterWasOn then
                pcall(SetRiftHunterEnabled, true)
            end
            ETP_RiftHunterWasOn = false
        end
    end
})

EggTP:Button({
    Title = "EMERGENCY: Special Egg (stop rifts + TP)",
    Desc = "Instantly disables ALL Rift features and teleports to the Special Egg spot.",
    Callback = function()
        -- 1) Disable all Rift functionality
        if _G.HardStopAllRifts then _G.HardStopAllRifts("Emergency override engaged.") else _G.__RiftEmergencyStop = true end
        pcall(function() if SetRiftHunterEnabled then SetRiftHunterEnabled(false) end end)
        __RiftHunterEnabled = false
        __AutoRespawnEnabled = false
        __FallbackEnabled = false
        -- stop fallback watch + any E spammers
        pcall(function() if __stopFallbackWatch then __stopFallbackWatch() end end)
        pcall(function() if _G.StopAutoPressE then _G.StopAutoPressE() end end)
        pcall(function() if _G.StopGlobalE then _G.StopGlobalE() end end)
        -- also turn off Egg TP watchers and reset status
        ETP_ENABLED = false
        pcall(function() if etpDisconnectAll then etpDisconnectAll() end end)
        etp_lastTarget = nil
        etpSetStatus("Status: Disabled by Emergency.")

        -- 2) Teleport to the emergency coordinates
        local hrp = getHRP()
        if hrp then
            local emergency = Vector3.new(-4921, 25, -579)
            hrp.CFrame = CFrame.new(emergency + Vector3.new(0, 3, 0))
            if WindUI then
                WindUI:Notify({ Title = "Emergency Teleport", Content = "All rift features OFF. Teleported to Special Egg.", Duration = 4, Icon = "alert-octagon" })
            end
        else
            if WindUI then
                WindUI:Notify({ Title = "Emergency Teleport", Content = "Character not ready to teleport.", Duration = 4, Icon = "alert-triangle" })
            end
        end
    end
})


---------------------------------------------------
-- Section C: Trick-or-Treat Loop (from TOT)     --
---------------------------------------------------
-- Coordinates
local eggs = {
    ["Pumpkin egg"] = Vector3.new(-4907.68, 25.20, -548.46),
    ["Costume egg"] = Vector3.new(-4917.93, 25.20, -548.29),
    ["Sinister egg"] = Vector3.new(-4929.31, 25.23, -548.13),
}

local houses = {
    {pos = Vector3.new(-4964.88, 18.37, -459.19), type = "Big"},
    {pos = Vector3.new(-5077.76, 21.57, -686.99), type = "Big"},
    {pos = Vector3.new(-4985.05, 16.26, -686.12), type = "Big"},
    {pos = Vector3.new(-4891.09, 21.81, -469.81), type = "Big"},
    {pos = Vector3.new(-5036.39, 22.32, -620.21), type = "Big"},
    {pos = Vector3.new(-5037.74, 24.42, -550.62), type = "Big"},
    {pos = Vector3.new(-5056.38, 21.55, -696.78), type = "Small"},
    {pos = Vector3.new(-5054.56, 21.60, -596.12), type = "Small"},
    {pos = Vector3.new(-4935.93, 18.31, -450.33), type = "Small"},
    {pos = Vector3.new(-4961.23, 15.59, -692.36), type = "Small"},
    {pos = Vector3.new(-5059.75, 24.39, -555.20), type = "Small"},
    {pos = Vector3.new(-4935.85, 18.31, -450.70), type = "Small"},
}

-- Player / character
local function getRoot()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart")
end

local function safeTeleport(pos)
    local root = getRoot()
    if not root then return end
    root.Anchored = true
    root.CFrame = CFrame.new(pos)
    root.Anchored = false
end

-- TrickOrTreat Remote
local TOTRemote = ReplicatedStorage:FindFirstChild("Shared")
    and ReplicatedStorage.Shared:FindFirstChild("Framework")
    and ReplicatedStorage.Shared.Framework:FindFirstChild("Network")
    and ReplicatedStorage.Shared.Framework.Network:FindFirstChild("Remote")
    and ReplicatedStorage.Shared.Framework.Network.Remote:FindFirstChild("RemoteEvent")

local HousesFolder do
    local he = Workspace:FindFirstChild("HalloweenEvent")
    HousesFolder = he and he:FindFirstChild("Houses") or nil
end

local selectedEgg = "Pumpkin egg"
local selectedHouseMode = "Both"
local TOT_ENABLED = false
local TOT_routine = nil

local function triggerTrickOrTreatFromPosition(pos)
    if not TOTRemote then warn("â ï¸ TrickOrTreat remote not found"); return end
    if not HousesFolder then warn("â ï¸ Houses folder not found"); return end

    local closestHouse, closestDist
    for _, house in ipairs(HousesFolder:GetChildren()) do
        if house:IsA("Model") and (house.Name == "House Big" or house.Name == "House Small") then
            local primary = house:FindFirstChildWhichIsA("BasePart", true)
            if primary then
                local dist = (primary.Position - pos).Magnitude
                if not closestDist or dist < closestDist then
                    closestHouse, closestDist = house, dist
                end
            end
        end
    end

    if closestHouse then
        TOTRemote:FireServer("TrickOrTreat", closestHouse)
        
    else
        warn("â ï¸ No nearby house found at:", pos)
    end
end

local TOTSection = EventTab:Section({ Title = "Trick-or-Treat", TextXAlignment = "Left", TextSize = 17, Opened = false })

local TOTStatus = TOTSection:Paragraph({ Title = "Status", Desc = "Disabled." })
local function setTOTStatus(t) if TOTStatus and TOTStatus.SetDesc then TOTStatus:SetDesc(t) end end

TOTSection:Dropdown({
    Flag = "SelectEggToHatch",
    Title = "Select Egg to Hatch",
    Values = {"Pumpkin egg","Costume egg","Sinister egg", "Mutant Egg"},
    Value = "Pumpkin egg",
    Callback = function(option)
        selectedEgg = option
        
    end
})

TOTSection:Dropdown({
    Flag = "HousesToTOT",
    Title = "Houses to TOT",
    Values = {"Both","Big","Small"},
    Value = "Both",
    Callback = function(option)
        selectedHouseMode = option
        
    end
})

TOTSection:Toggle({
    Flag = "EnableTrickOrTreatLoop",
    Title = "Enable Trick-or-Treat Loop",
    Value = false,
    Callback = function(state)
        TOT_ENABLED = state
        if state then
            if not TOT_routine then
                setTOTStatus("Enabled.")
                TOT_routine = task.spawn(function()
                    while TOT_ENABLED do
                        local eggPos = eggs[selectedEgg]
                        for _, house in ipairs(houses) do
                            if not TOT_ENABLED then break end

                            if selectedHouseMode == "Both" or selectedHouseMode == house.type then
                                safeTeleport(house.pos)
                                task.wait(math.random(10, 30) / 100)
                                triggerTrickOrTreatFromPosition(house.pos)
                                if eggPos then safeTeleport(eggPos) end
                                task.wait(3)
                            end
                        end
                    end
                    TOT_routine = nil
                end)
            end
        else
            setTOTStatus("Disabled.")
        end
    end
})

end


-- === Section: Halloween Wheel (moved) ===
local HalloweenWheelSection = CE:Section({ Title = "Halloween Wheel" })
HalloweenWheelSection:Toggle({
    Flag = "SAW",
    Title = "Auto Spin Halloween Wheel",
    Value = false,
    Callback = function(Value)
         _G.AutoSpinHalloweenWheel = Value
        if Value then task.spawn(SpinHalloweenWheel) end
    end
})

HalloweenWheelSection:Toggle({
    Flag = "SAWD",
    Title = "Auto Spin Dark Wheel",
    Value = false,
    Callback = function(Value)
         _G.AutoSpinDarkWheel = Value
        if Value then task.spawn(SpinDarkWheel) end
    end
})


HalloweenWheelSection:Toggle({
    Flag = "CAP",
    Title = "Auto Claim Halloween Free Spin",
    Value = false,
    Callback = function(Value)
        _G.AutoClaimHalloweenSpin = Value
        if Value then task.spawn(AutoClaimHalloweenSpin) end
    end
})

HalloweenWheelSection:Toggle({
    Flag = "CAPD",
    Title = "Auto Claim Dark Free Spin",
    Value = false,
    Callback = function(Value)
        _G.AutoClaimDarkSpin = Value
        if Value then task.spawn(AutoClaimDarkSpin) end
    end
})
-- === End Section: Halloween Wheel ===
-- == END: Current Event (merged) ==

    local SettingsTab = _G.__Tabs.Settings

    local TestSection = Window:Section({
        Title = "Mind Joining The Discord?",
        Icon = "nebula:nebula",
    })

    local thresholdSeconds = 60
WindUI:Notify({Title = "Rcash Hub", Content = "Shrine tab loaded into BGSI.", Duration = 3})
 
local ShrineTab = _G.__Tabs.Shrines

-- Global settings section
local GlobalSection = ShrineTab:Section({
    Title = "Global Settings",
    Opened = false,
    Box = false,
    TextSize = 17,
})

GlobalSection:Input({
    Flag = "AutoRenewThreshold",
    Title = "Auto-Renew Threshold",
    Placeholder = "e.g. 1:00",
    Default = "1:00",
    Numeric = false,
    Callback = function(text)
        thresholdSeconds = parseThreshold(text, 60)
        WindUI:Notify({
            Title = "Auto-Renew Threshold",
            Content = ("Set to %ds for both Bubble & Dreamer"):format(thresholdSeconds),
            Duration = 3
        })
    end
})

-- Bubble shrine section
local allPotionNames = { "Speed", "Lucky", "Coins", "Mythic", "Tickets", "Secret Elixir", "Egg Elixir", "Infinity Elixir", "Halloween Elixir", "Halloween Infinity Elixir" }
local selectedPotion = allPotionNames[1]
local selectedTier = 1
local donateAmount = 1
local bubbleAutoEnabled = false
local bubbleCheckInterval = 1.0

-- Helper: simple cooldown factory. Returns a function that returns true
-- the first time it's called after 'seconds' have passed since last success.
local function makeCooldown(seconds)
    local last = 0
    seconds = tonumber(seconds) or 0
    return function()
        local now = (tick and tick() or os.time())
        if now - last >= seconds then
            last = now
            return true
        end
        return false
    end
end

local bubbleCooldownOk = makeCooldown(5)

local BubbleSection = ShrineTab:Section({
    Title = "Bubble Shrine Donations",
    Opened = false,
    Box = false,
})

BubbleSection:Paragraph({
    Title = "Bubble Shrine Donations",
    Desc = "Donate any potion tier/type to the Bubble Shrine."
})

BubbleSection:Dropdown({
    Flag = "PotionType",
    Title = "Potion Type",
    Values = allPotionNames,
    Value = selectedPotion,
    Multi = false,
        Callback = function(v)
        selectedPotion = v
    end
})

BubbleSection:Dropdown({
    Flag = "PotionTier",
    Title = "Potion Tier",
    Values = { "1", "2", "3", "4", "5", "6", "7" },
    Value = "1",
    Multi = false,
        Callback = function(v)
        selectedTier = tonumber(v)
    end
})

BubbleSection:Input({
    Flag = "AmountToDonate",
    Title = "Amount to Donate",
    Placeholder = "Enter number, e.g. 50",
    Default = "1",
    Numeric = true,
    Callback = function(value)
        local n = tonumber(value)
        if not n or n < 1 then
            return WindUI:Notify({
                Title = "Invalid Input",
                Content = "Please enter a valid positive number.",
                Duration = 3
            })
        end
        donateAmount = math.floor(n)
    end
})

local function getPotionData(name, tier)
    local data = LocalData:Get()
    if not (data and data.Potions) then return nil end
    for _, potion in ipairs(data.Potions) do
        if potion.Name == name and potion.Level == tier then
            return potion
        end
    end
    return nil
end

local function getElixirData(name)
    local data = LocalData:Get()
    if not (data and data.Potions) then return nil end
    for _, potion in ipairs(data.Potions) do
        if potion.Name == name and not potion.Level then
            return potion
        end
    end
    return nil
end

local function donateOnce()
    local isElixir = string.find(selectedPotion:lower(), "elixir")
    local potion, finalAmount, args

    if isElixir then
        potion = getElixirData(selectedPotion)
        if not potion then
            return WindUI:Notify({
                Title = "Bubble Shrine",
                Content = "â You donât own any " .. selectedPotion .. ".",
                Duration = 4
            })
        end
        finalAmount = math.min(potion.Amount, donateAmount)
        args = { "DonateToShrine", { Type = "Elixir", Name = selectedPotion, Amount = finalAmount } }
    else
        potion = getPotionData(selectedPotion, selectedTier)
        if not potion then
            return WindUI:Notify({
                Title = "Bubble Shrine",
                Content = string.format("â You have no Tier %d %s potions.", selectedTier, selectedPotion),
                Duration = 4
            })
        end
        finalAmount = math.min(potion.Amount, donateAmount)
        args = { "DonateToShrine", { Type = "Potion", Level = selectedTier, Name = selectedPotion, Amount = finalAmount } }
    end

    
    local result = RemoteFunction:InvokeServer(unpack(args))
    WindUI:Notify({
        Title = "Bubble Shrine",
        Content = string.format("â Donated %d Ã %s%s", finalAmount, selectedPotion, isElixir and "" or (" (Tier " .. selectedTier .. ")")),
        Duration = 4
    })
    return result
end

BubbleSection:Toggle({
    Flag = "AutoRenewBubbleBlessing",
    Title = "Auto-Renew Bubble Blessing",
    Value = false,
        Callback = function(v)
        bubbleAutoEnabled = v
        if v then
            WindUI:Notify({ Title = "Bubble Auto-Renew", Content = "Using global threshold.", Duration = 3 })
            task.spawn(function()
                while bubbleAutoEnabled do
                    local secs = getLabelSeconds({
                        "Players", Players.LocalPlayer.Name,
                        "PlayerGui", "ScreenGui", "Buffs", "ShrineBlessing", "Button", "Label"
                    })
                    if secs and secs <= thresholdSeconds then
                        if bubbleCooldownOk() then
                            task.spawn(donateOnce)
                        end
                    end
                    task.wait(bubbleCheckInterval)
                end
            end)
        else
            WindUI:Notify({ Title = "Bubble Auto-Renew", Content = "Stopped.", Duration = 3 })
        end
    end
})

BubbleSection:Button({
    Title = "Donate Once (Bubble Shrine)",
    
    Icon = "",
    Callback = donateOnce
})

-- Dreamer shrine section
do
    local DONATE_AMOUNT = 100
    local PREFER_EXACT_100 = true

    local function getDreamRemoteFunction()
        local ok, rf = pcall(function()
            return game:GetService("ReplicatedStorage")
                :WaitForChild("Shared")
                :WaitForChild("Framework")
                :WaitForChild("Network")
                :WaitForChild("Remote")
                :WaitForChild("RemoteFunction")
        end)
        if ok then return rf end
        return nil
    end

    local function getFishInventory()
        local dataOk, data = pcall(function()
            return LocalData and LocalData:Get()
        end)
        if not dataOk or not data then return nil end
        if typeof(data.FishInventory) == "table" then
            return data.FishInventory
        end
        return nil
    end

    local function pickFishForDonation(threshold, preferExact)
        local inv = getFishInventory()
        if not inv then return nil end

        if preferExact then
            for _, fish in ipairs(inv) do
                if fish and fish.Id and type(fish.Amount) == "number"
                    and (fish.Locked == false or fish.Locked == nil)
                    and fish.Amount == threshold
                then
                    return fish
                end
            end
        end

        local best = nil
        for _, fish in ipairs(inv) do
            if fish and fish.Id and type(fish.Amount) == "number"
                and (fish.Locked == false or fish.Locked == nil)
                and fish.Amount >= threshold
            then
                if not best or fish.Amount > best.Amount then
                    best = fish
                end
            end
        end
        return best
    end

    local function donateToDreamShrine(amount)
        amount = tonumber(amount) or DONATE_AMOUNT
        if amount < 1 then amount = 1 end

        local fish = pickFishForDonation(amount, PREFER_EXACT_100)
        if not fish then
            if WindUI then
                WindUI:Notify({
                    Title = "Dreamer Shrine",
                    Content = ("â No species has at least %d available."):format(amount),
                    Duration = 5
                })
            end
            warn(("[DreamShrine] No species has at least %d available."):format(amount))
            return nil
        end

        local rf = getDreamRemoteFunction()
        if not rf then
            if WindUI then
                WindUI:Notify({
                    Title   = "Dreamer Shrine",
                    Content = "â RemoteFunction not found at Shared/Framework/Network/Remote/RemoteFunction",
                    Duration= 5
                })
            end
            warn("[DreamShrine] RemoteFunction not found.")
            return nil
        end

        local args = { "DonateToDreamerShrine", fish.Id, amount }
        

        local ok, result = pcall(function()
            return rf:InvokeServer(unpack(args))
        end)

        if not ok then
            if WindUI then
                WindUI:Notify({
                    Title = "Dreamer Shrine",
                    Content = "â Donation failed: "..tostring(result),
                    Duration = 5
                })
            end
            warn("[DreamShrine] InvokeServer failed: ", result)
            return nil
        end

        if WindUI then
            WindUI:Notify({
                Title = "Dreamer Shrine",
                Content = ("â Donated %d Ã %s"):format(amount, fish.Name or "Unknown"),
                Duration = 4
            })
        end

        return result
    end

    _G.DreamShrineDonate = donateToDreamShrine

    local dreamAutoEnabled = false
    local dreamCheckInterval = 1.0
    local dreamCooldownOk = makeCooldown(5)
    local currentAmount = DONATE_AMOUNT

    local DreamSection = ShrineTab:Section({
        Title = "Dreamer Shrine Donations",
        Opened = false,
        Box = false,
    })

    DreamSection:Paragraph({
        Title = "Dreamer Shrine Donations",
        Desc  = "Auto-pick a fish with enough quantity to donate for max buff."
    })

    DreamSection:Input({
        Flag = "DreamerDonateAmount",
        Title = "Dreamer Donate Amount",
        Placeholder = "Enter number, e.g. 100",
        Default = tostring(currentAmount),
        Numeric = true,
        Callback = function(value)
            local n = tonumber(value)
            if not n or n < 1 then
                if WindUI then
                    WindUI:Notify({
                        Title = "Invalid Input",
                        Content = "Please enter a valid positive number.",
                        Duration = 3
                    })
                end
                return
            end
            currentAmount = math.floor(n)
        end
    })

    DreamSection:Button({
        Title = "Donate Set Amount",
        
        Icon = "",
        Callback = function()
            donateToDreamShrine(currentAmount)
        end
    })

    DreamSection:Button({
        Title = "Donate 100",
        
        Icon = "",
        Callback = function()
            donateToDreamShrine(100)
        end
    })

    DreamSection:Toggle({
        Flag = "AutoRenewDreamerBlessing",
        Title = "Auto-Renew Dreamer Blessing",
        Value = false,
        Callback = function(v)
            dreamAutoEnabled = v
            if v then
                WindUI:Notify({ Title = "Dreamer Auto-Renew", Content = "Using global threshold.", Duration = 3 })
                task.spawn(function()
                    while dreamAutoEnabled do
                        local secs = getLabelSeconds({
                            "Players", Players.LocalPlayer.Name,
                            "PlayerGui", "ScreenGui", "Buffs", "DreamerBlessing", "Button", "Label"
                        })
                        if secs and secs <= thresholdSeconds then
                            if dreamCooldownOk and dreamCooldownOk() then
                                task.spawn(function()
                                    donateToDreamShrine(currentAmount)
                                end)
                            end
                        end
                        task.wait(dreamCheckInterval)
                    end
                end)
            else
                WindUI:Notify({ Title = "Dreamer Auto-Renew", Content = "Stopped.", Duration = 3 })
            end
        end
    })
end

Window:SelectTab(1)

-- Information Tab
    -- Discord
    local InviteCode = "JQFrBajQxW"
    local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

    local Response
    local ErrorMessage = nil

    xpcall(function()
        Response = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
            Url = DiscordAPI,
            Method = "GET",
            Headers = {
                ["Accept"] = "application/json"
            }
        }).Body)
    end, function(err)
        warn("err fetching discord info: " .. tostring(err))
        ErrorMessage = tostring(err)
        Response = nil
    end)

    if Response and Response.guild then
        local ParagraphConfig = {
            Title = Response.guild.name,
            Desc =
                ' <font color="#52525b">â¢</font> Member Count: ' .. tostring(Response.approximate_member_count) ..
                '\n <font color="#16a34a">â¢</font> Online Count: ' .. tostring(Response.approximate_presence_count),
            Image = "https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=256",
            ImageSize = 42,
            Buttons = {
                {
                    Icon = "link",
                    Title = "Copy Discord Invite",
                    Callback = function()
                        pcall(function()
                            setclipboard("https://discord.gg/" .. InviteCode)
                        end)
                        WindUI:Notify({
                            Title = "Rcash Hub",
                            Content = "Link Copied to Clip Board!",
                            Duration = 3,
                            Icon = "link",
                        })
                    end
                },
                {
                    Icon = "refresh-cw",
                    Title = "Update Info",
                    Callback = function()
                        xpcall(function()
                            local UpdatedResponse = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
                                Url = DiscordAPI,
                                Method = "GET",
                            }).Body)
                        
                            if UpdatedResponse and UpdatedResponse.guild then
                                DiscordInfo:SetDesc(
                                    ' <font color="#52525b">â¢</font> Member Count: ' .. tostring(UpdatedResponse.approximate_member_count) ..
                                    '\n <font color="#16a34a">â¢</font> Online Count: ' .. tostring(UpdatedResponse.approximate_presence_count)
                                )
                            end
                        end, function(err)
                            warn("err updating discord info: " .. tostring(err))
                        end)
                    end
                }
            }
        }
    
        if Response.guild.banner then
            ParagraphConfig.Thumbnail = "https://cdn.discordapp.com/banners/" .. Response.guild.id .. "/" .. Response.guild.banner .. ".png?size=256"
            ParagraphConfig.ThumbnailSize = 80
        end
    
        local DiscordInfo = InfoTab:Paragraph(ParagraphConfig)
    else
        InfoTab:Paragraph({
            Title = "Error when receiving information about the Discord server",
            Desc = ErrorMessage or "Unknown error occurred",
            Image = "triangle-alert",
            ImageSize = 26,
            Color = "Red",
        })
    end

    InfoTab:Paragraph({
        Title = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name,
        Desc = string.format([[Rcash Hub %s

FEATURES:

> - Auto blow bubbles
> - Auto collect all pickups
> - Sell all items
> - Auto obby
> - Anti-AFK protection
> - Auto-reconnect on disconnect
> - Save and load config
> - Auto-load your preferred setup on startup
> - Multiple theme options for personalization
> - Auto Minigames
> - Performance Mode
> - Auto Add Friends
> - Auto Fish
> - Auto Enchant
> - Auto Competitive Quest
> - Auto Trade (For BloxyCross)
> - Auto Upgrade (Halloween)
> - Trick Or Treat (Halloween)
> - Auto Summon Rift
> - Auto Buy Shops
> - Auto Shrines
> - Auto Rift
> - Auto Board Game
> - Animations Block (On By Deafault)
> - Auto Potions
> - Auto Craft Potions

CONTROLS:

> - Right Ctrl = Show/Hide Interface

CHANGELOGS:

v1.4
> - Auto Minigames
> - Performance Mode
> - Auto Add Friends
> - Auto Fish
> - Auto Enchant
> - Auto Competitive Quest
> - Auto Trade (For BloxyCross)
> - Auto Upgrade (Halloween)
> - Trick Or Treat (Halloween)
> - Auto Summon Rift
> - Auto Buy Shops
> - Auto Shrines
> - Auto Rift
> - Auto Board Game
> - Animations Block (On By Deafault)
> - Auto Potions
> - Auto Craft Potions

v1.3
> - Added Nebula icon library for enhanced UI
> - Custom background image for main window
> - Improved theme system with dropdown and toggle
> - Enhanced egg selection with search bar

v1.2
> - Added Anti-AFK system
> - Added Auto-reconnect feature
> - Improved config save/load

By RdotA and Issa <3]], SCRIPT_VERSION)
    })

-- Server Settings
    SS:Button({
        Title = "Rejoin Server",
        
        Value = false,
        Callback = function(Value)
            game:GetService("TeleportService"):Teleport(game.PlaceId, game.Players.LocalPlayer)
        end
    })

    SS:Button({
        Title = "Server Hop",
        
        Value = false,
        Callback = function(Value)
            local Servers = {}
            local PlaceID = game.PlaceId
            local AllIDs = {}
            local foundAnything = ""
            local actualHour = os.date("!*t").hour
            local Deleted = false
        
            function TPReturner()
                local Site;
                if foundAnything == "" then
                    Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
                else
                    Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
                end
                local ID = ""
                if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
                    foundAnything = Site.nextPageCursor
                end
                local num = 0;
                for i,v in pairs(Site.data) do
                    if v.playing ~= v.maxPlayers then
                        if v.id ~= game.JobId then
                            table.insert(Servers, v.id)
                        end
                    end
                end
            end
        
            function Teleport()
                if #Servers > 0 then
                    game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, Servers[math.random(1, #Servers)], LocalPlayer)
                else
                    TPReturner()
                    wait(1)
                    Teleport()
                end
            end
        
            TPReturner()
            wait(1)
            Teleport()
        end
    })

    SS:Divider()

    SS:Button({
        Title = "Reload Rcash Hub",
        
        Value = false,
        Callback = function(Value)
            Window:Destroy()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/IRdotAI/Rcash-Hub/refs/heads/main/BGSI.lua"))()
        end
    })

    SS:Button({
        Title = "Destroy GUI",
        
        Value = false,
        Callback = function(Value)
            WindUI:Notify({
                Title = "Rcash Hub",
                Content = "Rcash hub Destroyed!",
                Duration = 1,
                Icon = "shredder",
            })
            task.wait(1) 
            Window:Destroy()
        end
    })

-- Farm Tab

    local AutoFarmSec = FarmTab:Section({
        Title = "Auto Farming",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })
    


AutoFarmSec:Button({
    Title = "Set Farming Egg (use current position)",
    
    Icon = "map-pin",
    Callback = function()
        SetFarmingEggHere()
    end
})

AutoFarmSec:Button({
    Title = "Teleport to Farming Egg",
    
    Icon = "navigation",
    Callback = function()
        TeleportToFarmingEgg()
    end
})


AutoFarmSec:Paragraph({
        Title = "Auto Sell",
        Desc = string.format([[
To change the timer for the auto sell you MUST first turn off auto sell and then change it then turn it back on again
]], SCRIPT_VERSION)
    })

    AutoFarmSec:Toggle({
        Flag = "AS",
        Title = "Enable Auto Sell",
        Value = false,
        Callback = function(value)
            _G.AutoSell = value
            if value then
                AutoSellFunction()
            end
        end
    })

    AutoFarmSec:Dropdown({
        Flag = "SL",
        Title = "Fallback Sell Location",
        Values = { "Twilight Overworld", "Base (W1 Surface)", "Minigame World (W2 Surface)", "Minigame World Robot Factory", "Bubble Rift" },
        Value = "Twilight Overworld",
        Callback = function(option)
            _G.SelectedFallback = option
            
        end
    })

    AutoFarmSec:Slider({
        Flag = "BST",
        Title = "Bubble Sell Timer (seconds)",
        Step = 1,
        Value = {
            Min = 2,
            Max = 60,
            Default = 2,
        },
        Callback = function(value)
            _G.SellTimer = value
            
        end
    })

    AutoFarmSec:Toggle({
        Flag = "ABB",
        Title = "Auto Blow Bubbles",
        Value = false,
        Callback = function(Value)
            _G.AutoBlowBubbles = Value
            if Value then task.spawn(AutoBlowBubbles) end
        end
    })
    AutoFarmSec:Toggle({
        Flag = "CP",
        Title = "Auto Collect Pickups",
        Value = false,
        Callback = function(Value)
            _G.AutoCollectPickups = Value
        end
    })


    AutoFarmSec:Button({
        Title = "Force-Load All Chunkers",
        Icon = "box",
        Callback = function()
            -- One-shot: find and force-load all live Chunker instances
            local modified = 0
            for _, ch in next, getgc(true) do
                if type(ch) == "table"
                    and type(rawget(ch, "_chunks")) == "table"
                    and type(rawget(ch, "_loaded")) == "table"
                    and typeof(rawget(ch, "_folder")) == "Instance"
                    and rawget(ch, "_folder").Name == "Chunker"
                    and type(rawget(ch, "Loaded")) == "table"
                    and type(rawget(ch, "Unloaded")) == "table" then

                    local chunks = rawget(ch, "_chunks")
                    local loaded = rawget(ch, "_loaded")
                    local folder = rawget(ch, "_folder")

                    -- Prevent future unloads
                    ch.Update = function() end

                    for coord, list in next, chunks do
                        if type(list) == "table" then
                            loaded[coord] = true
                            for _, thing in next, list do
                                if typeof(thing) == "Instance" then
                                    thing.Parent = folder
                                end
                                pcall(function()
                                    if ch.Loaded and ch.Loaded.Fire then
                                        ch.Loaded:Fire(thing, coord)
                                    end
                                end)
                            end
                        end
                    end
                    modified += 1
                end
            end

            WindUI:Notify({
                Title = "Chunker",
                Content = ("Forced loaded %d chunker(s)"):format(modified),
                Duration = 3
            })
        end
    })

    AutoFarmSec:Toggle({
        Flag = "CO",
        Title = "Auto Complete Obbys",
        Value = false,
        Callback = function(state)
            _G.AutoObby = state
            if state then
                WindUI:Notify({
                    Title = "Rcash Hub",
                    Content = "Auto Obby & Chests now working!",
                    Duration = 3
                })
            else
                WindUI:Notify({
                    Title = "Rcash Hub",
                    Content = "Auto Obbys Paused",
                    Duration = 3
                })
            end
        end
    })

-- Pets Tab
    MiscSection:Toggle({
        Flag = "EBP",
        Title = "Auto Equip Best Pet",
        Value = false,
        Callback = function(Value)
            _G.AutoEquipBest = Value
            if Value then task.spawn(AutoEquipBest) end
        end
    })

    MiscSection:Toggle({
        Flag = "DUP",
        Title = "Auto Delete Unused Pets",
        Value = false,
        Callback = function(Value)
            _G.AutoSellPets = Value
            if Value then task.spawn(AutoSellPets) end
        end
    })
    task.spawn(function()
        while task.wait(2) do
            if WindUI.Unloaded then break end
            local newList = getEquippedPetsData()
            if table.concat((function() local n = {} for _,v in ipairs(newList) do table.insert(n, v.name) end return n end)(), ",") ~= table.concat((function() local n = {} for _,v in ipairs(equippedPetsData) do table.insert(n, v.name) end return n end)(), ",") then
                equippedPetsData = newList
                local namesOnly = {}
                for _,v in ipairs(equippedPetsData) do table.insert(namesOnly, v.name) end
            
                PetDropdown:SetValues(namesOnly, currentSelectedPetNames)
            end
        end
    end
    )

-- Hatch Tab

    local AutoHatchSec = HatchTab:Section({ 
        Title = "Auto Hatch",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })
    local InventoryEggSec = HatchTab:Section({ 
        Title = "Hatch Inventory Eggs",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })
    -- Injected: Farming Egg option support for Hatch dropdown
local FarmingEggDropdownValues = (function()
    local list = {}
    table.insert(list, "Farming Egg")
    for _, name in ipairs(EggDisplayNames) do table.insert(list, name) end
    return list
end)()

AutoHatchSec:Dropdown({
        Flag = "EGGTP",
        Title = "Select Egg to Teleport/Hatch",
        Desc = "Select an egg to automatically teleport to it and set it for AutoHatch.",
        Values = FarmingEggDropdownValues, 
        Value = "",
        SearchBarEnabled = true, 
        Callback = function(Value)
            if Value == "Farming Egg" then
            if _G.FarmingEggPosition then
                _G.SelectedEgg = "__FARMING_EGG__"
                TeleportToFarmingEgg()
                WindUI:Notify({ Title = "Rcash Hub", Content = "Using Farming Egg for teleport.", Duration = 4, Icon = "info" })
            else
                WindUI:Notify({ Title = "Rcash Hub", Content = "No Farming Egg set. Use âSet Farming Eggâ in Auto Farming.", Duration = 5, Icon = "map-pin-off" })
            end
            return
        end
        _G.SelectedEgg = Value
        TeleportToEgg(Value)
        end
    })

    AutoHatchSec:Button({
        Flag = "EGGTPBTN",
        Title = "Teleport To Selected Egg",
        
        Value = false,
        Callback = function(Value)
            if _G.SelectedEgg ~= "" then 
                TeleportToEgg(_G.SelectedEgg)
            else 
                WindUI:Notify({
                    Title = "Rcash Hub ",
                    Content = "Please select an egg first.",
                    Duration = 3,
                    Icon = "shield-alert",
                })
            end
        end
    })

    AutoHatchSec:Toggle({
        Flag = "AH",
        Title = "Auto Hatch",
        Value = false,
        Callback = function(Value)
            _G.AutoHatch = Value
            if Value then
                task.spawn(AutoHatch)
            end
        end
    })

    AutoHatchSec:Toggle({
        Flag = "SE",
        Title = "Auto Spam E",
        Desc = "Auto Spam The Key `E` For Faster Hatching And Auto Obby",
        Value = false,
        Callback = function(Value)
            _G.SpamE = Value
            if Value then
                task.spawn(SpamEKey)
            end
        end
    })

    AutoHatchSec:Toggle({
        Flag = "HHA",
        Title = "Hide Hatch Animation",
        Value = false,
        Callback = function(Value)
            _G.HideHatchAnim = Value
        end
    })

    local inventoryEggDropdown = InventoryEggSec:Dropdown({
        Flag = "IEGD",
        Title = "Select Inventory Egg to Hatch",
        Values = inventoryEggDisplayNames,
        Value = "None",
        Callback = function(Value)
            if Value and Value ~= "None" then
                _G.SelectedInventoryEgg = Value:match("(.+): %d+") or Value
                WindUI:Notify({
                    Title = "Rcash Hub ",
                    Content = "Selected Inventory Egg: " .. _G.SelectedInventoryEgg,
                    Duration = 3,
                    Icon = "egg",
                })
            else
                _G.SelectedInventoryEgg = "None"
            end
        end
    })

-- Create toggle
    InventoryEggSec:Toggle({
        Flag = "AHIE",
        Title = "Auto Hatch Selected Inventory Egg",
        Value = false,
        Callback = function(Value)
            _G.AutoHatchInventoryEggs = Value
            if Value and _G.SelectedInventoryEgg == "None" then
                WindUI:Notify({
                    Title = "Rcash Hub ",
                    Content = "Please select an inventory egg first.",
                    Duration = 3,
                    Icon = "shield-alert",
                })
                _G.AutoHatchInventoryEggs = false
            elseif Value then
                task.spawn(AutoHatchInventoryEggs)
            end
        end
    })

-- Misc Tab

    local AutoSec = MiscTab:Section({ 
        Title = "Rewards Automation",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })

    AutoSec:Toggle({
        Flag = "CPR",
        Title = "Auto Claim Playtime Rewards",
        Value = false,
        Callback = function(Value)
            _G.AutoClaimPTR = Value
            if Value then task.spawn(AutoClaimPTR) end
        end
    })

    AutoSec:Toggle({
        Flag = "CSR",
        Title = "Auto Claim Season Rewards",
        Value = false,
        Callback = function(Value)
            _G.AutoCS = Value
            if Value then task.spawn(AutoCS) end
        end
    })

    AutoSec:Toggle({
        Flag = "ACFS",
        Title = "Auto Claim Festival Spin",
        Value = false,
        Callback = function(Value)
            _G.AutoClaimFestivalSpin = Value
            if Value then task.spawn(SpinFestivalWheel) end
        end
    })

    AutoSec:Toggle({
        Flag = "GORB",
        Title = "Auto Use Golden Orb",
        Value = false,
        Callback = function(Value)
            _G.AutoGoldenOrb = Value
            if Value then task.spawn(AutoGoldenOrb) end
        end
    })

    AutoSec:Toggle({
        Flag = "ACAC",
        Title = "Auto Claim All Chests",
        Value = false,
        Callback = function(Value)
            _G.AutoClaimAllChests = Value
            if Value then task.spawn(AutoClaimAllChests) end
        end
    })

    -- == BEGIN: Social & Trading (Misc tab) ==
    local SocialSec = MiscTab:Section({
        Title = "Trading & Friend All",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })

    -- Services & remotes (local handles here to avoid relying on prior locals)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local TradeEvent = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent

    -- Optional labeling for known bots (used only to decorate dropdown list)
    local botNames = {"BGALEC", "JennaFans4"}

    -- Build initial player list with labels
    local function buildPlayersList()
        local list = {}
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                local name, label = player.Name, ""
                for _, bot in ipairs(botNames) do
                    if name == bot then
                        label = " (BloxyCross Bot)"
                        break
                    end
                end
                table.insert(list, name .. label)
            end
        end
        return list
    end

    -- ===== Auto Add Friends =====
    SocialSec:Toggle({
        Flag = "AutoFriendAll",
        Title = "Auto Friend All",
        Value = false,
        Callback = function(state)
            local localPlayer = Players.LocalPlayer

            local function addAllFriends()
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= localPlayer and not localPlayer:IsFriendsWith(player.UserId) then
                        localPlayer:RequestFriendship(player)
                    end
                end
            end

            if state then
                addAllFriends()
                -- keep friending new joins
                getgenv().AutoFriendConnection = Players.PlayerAdded:Connect(function(newPlayer)
                    if newPlayer ~= localPlayer and not localPlayer:IsFriendsWith(newPlayer.UserId) then
                        localPlayer:RequestFriendship(newPlayer)
                    end
                end)
            else
                if getgenv().AutoFriendConnection then
                    getgenv().AutoFriendConnection:Disconnect()
                    getgenv().AutoFriendConnection = nil
                end
            end
        end
    })

    SocialSec:Divider()

    -- ===== Auto Trade =====
    -- settings bucket (kept in getgenv so reloads don't nuke it)
    getgenv().Settings = getgenv().Settings or {
        Start = false,
        TargetNames = {"BGALEC", "JennaFans4"},
    }

    -- auto-accept incoming requests when toggled
    local autoAccept = false
    TradeEvent.OnClientEvent:Connect(function(action, sender)
        if autoAccept and action == "TradeRequest" then
            TradeEvent:FireServer("AcceptTradeRequest", sender)
        end
    end)

    SocialSec:Toggle({
        Flag = "AutoAcceptTrade",
        Title = "Auto Accept Trade",
        Value = false,
        Callback = function(v)
            autoAccept = v
        end
    })

    SocialSec:Toggle({
        Flag = "AutoTradeRequest",
        Title = "Auto Trade Request",
        Value = false,
        Callback = function(v)
            getgenv().Settings.Start = v
        end
    })

    local selectedTarget = nil
    local playersIngameList = buildPlayersList()

    local PlayersDropdown = SocialSec:Dropdown({
        Flag = "Players",
        Title = "Players",
        Value = "",
        Values = playersIngameList,
        Callback = function(value)
            -- strip label (e.g., " (BloxyCross Bot)")
            selectedTarget = value and value:match("^[^%s]+") or nil
            if selectedTarget then
                getgenv().Settings.TargetNames = { selectedTarget }
            end
        end
    })

    -- keep dropdown fresh as players join/leave
    task.spawn(function()
        while task.wait(3) do
            if not PlayersDropdown or not PlayersDropdown.Refresh then break end
            PlayersDropdown:Refresh(buildPlayersList())
        end
    end)

    -- loop to send outgoing requests while enabled
    task.spawn(function()
        while task.wait() do
            if getgenv().Settings.Start then
                for _, targetName in ipairs(getgenv().Settings.TargetNames) do
                    local target = Players:FindFirstChild(targetName)
                    if target then
                        TradeEvent:FireServer("TradeRequest", target)
                        task.wait(0.4)
                    end
                end
            end
        end
    end)

    MiscTab:Dropdown({
        Flag = "GD",
        Title = "Select Item to Auto-Use",
        Values = GiftDisplayNames,
        Value = GiftDisplayNames[1],
        Callback = function(Value)
            if Value and Value ~= "None" then
                _G.SelectedGift = Value:match("(.+): %d+") or Value
                _G.GiftsToOpen = {_G.SelectedGift}
            else
                _G.SelectedGift = "None"
                _G.GiftsToOpen = {}
            end
        
            WindUI:Notify({
                Title = "Rcash Hub ",
                Content = "Auto-Use Item set to: " .. _G.SelectedGift,
                Duration = 3,
                Icon = "gift",
            })
        end
    })

    MiscTab:Toggle({
        Flag = "OSG",
        Title = "Auto Open Selected Gift",
        Value = false,
        Callback = function(Value)
            _G.AutoUseSelectedGift = Value
            _G.AutoGift = Value
            if Value then 
                task.spawn(AutoUseSelectedGift)
                task.spawn(runGiftController)
            end
        end
    })

    MiscTab:Toggle({
        Flag = "SGA",
        Title = "Skip Gift Animation",
        Value = false,
        Callback = function(Value)
            _G.SkipGiftAnimation = Value
            _G.AutoGift = Value
            if Value then
                task.spawn(runGiftController)
            end
        end
    })

-- Current Events Tab
    

    

    

-- Settings Tab
    -- [[ Performance Settings Integration ]]
    local StarterGui = game:GetService("StarterGui")
    local VirtualUser = game:GetService("VirtualUser")
    local Lighting = game:GetService("Lighting")

    -- State
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    local uiVisibilityState = {}
    if playerGui then
        for _, gui in pairs(playerGui:GetChildren()) do
            if gui:IsA("ScreenGui") then
                uiVisibilityState[gui] = gui.Enabled
            end
        end
    end

    local PerformanceMode = false
    local Originals = {}
    local afkMode = false
    local antiAFKConnection

    local ToDisable = {
        Textures = true,
        VisualEffects = true,
        Parts = true,
        Particles = true,
        Sky = true
    }

    local ToEnable = {
        FullBright = false
    }

    local function toggleRendering(state)
        pcall(function()
            RunService:Set3dRenderingEnabled(state)
        end)
    end

    local function toggleUI(state)
        pcall(function()
            StarterGui:SetCore("TopbarEnabled", state)
        end)
        if playerGui then
            for _, gui in pairs(playerGui:GetChildren()) do
                if gui:IsA("ScreenGui") then
                    gui.Enabled = state and (uiVisibilityState[gui] or false)
                end
            end
        end
    end

    local function toggleAFKMode(state)
        afkMode = state
        toggleRendering(not afkMode)
        toggleUI(not afkMode)
    end

    local function DisablePerformance()
        local Stuff = {}
        for _, v in next, game:GetDescendants() do
            if ToDisable.Parts then
                if v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("BasePart") then
                    Originals[v] = Originals[v] or {Material = v.Material}
                    pcall(function() v.Material = Enum.Material.SmoothPlastic end)
                    table.insert(Stuff, v)
                end
            end

            if ToDisable.Particles then
                if v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Explosion") or v:IsA("Sparkles") or v:IsA("Fire") then
                    Originals[v] = Originals[v] or {Enabled = v.Enabled}
                    pcall(function() v.Enabled = false end)
                    table.insert(Stuff, v)
                end
            end

            if ToDisable.VisualEffects then
                if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("DepthOfFieldEffect") or v:IsA("SunRaysEffect") then
                    Originals[v] = Originals[v] or {Enabled = v.Enabled}
                    pcall(function() v.Enabled = false end)
                    table.insert(Stuff, v)
                end
            end
        end

        if ToDisable.Sky then
            local Lighting = game:GetService("Lighting")
            for _, v in next, Lighting:GetChildren() do
                if v:IsA("Sky") then
                    Originals[v] = Originals[v] or {Parent = v.Parent}
                    pcall(function() v.Parent = nil end)
                end
            end
        end

        if ToEnable.FullBright then
            local Lighting = game:GetService("Lighting")
            Originals[Lighting] = Originals[Lighting] or {
                Ambient = Lighting.Ambient,
                Brightness = Lighting.Brightness,
                ColorShift_Bottom = Lighting.ColorShift_Bottom,
                ColorShift_Top = Lighting.ColorShift_Top,
                OutdoorAmbient = Lighting.OutdoorAmbient,
                FogColor = Lighting.FogColor,
                FogEnd = Lighting.FogEnd,
                FogStart = Lighting.FogStart,
                Outlines = Lighting.Outlines
            }

            Lighting.FogColor = Color3.fromRGB(255, 255, 255)
            Lighting.FogEnd = math.huge
            Lighting.FogStart = math.huge
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.Brightness = 5
            Lighting.ColorShift_Bottom = Color3.fromRGB(255, 255, 255)
            Lighting.ColorShift_Top = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            Lighting.Outlines = true
        end
    end

    local function RestorePerformance()
        for obj, orig in pairs(Originals) do
            for prop, val in pairs(orig) do
                pcall(function()
                    obj[prop] = val
                end)
            end
        end
        Originals = {}
    end

    local PerformanceSection = SettingsTab:Section({
        Title = "Performance Settings",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })

    PerformanceSection:Toggle({
        Flag = "PERFM",
        Title = "Performance Mode",
        Value = false,
        Callback = function(Value)
            PerformanceMode = Value
            if Value then
                DisablePerformance()
            else
                RestorePerformance()
            end
        end
    })
    -- === Added: Workspace Optimizer Button (Irreversible) ===
    PerformanceSection:Button({
        Title = "Optimize And Delete Models (Irreversible)",
        Color = "Red",
        Icon = "trash-2",
        Callback = function()
            xpcall(function()
                ----------------------------------------------------------------
                --                    optimizer.lua INLINED                   --
                -- Everything below sets up all optimizer systems, and        --
                -- triggers one strict cleanup pass NOW (button press only).  --
                -- No run-on-execute, no optimizer keybind.                   --
                ----------------------------------------------------------------

                ---------------------- Emitter Muzzle -------------------------
                do
                    if not _G.__EMITTER_MUZZLE_V1__ then
                        _G.__EMITTER_MUZZLE_V1__ = true
                        task.defer(function()
                            local RS = game:GetService("ReplicatedStorage")
                            local ok, mod = pcall(function()
                                local classes = RS:FindFirstChild("Shared") and RS.Shared:FindFirstChild("Framework") and RS.Shared.Framework:FindFirstChild("Classes")
                                local emitterMod = classes and classes:FindFirstChild("Emitter")
                                if not emitterMod then return nil end
                                return require(emitterMod)
                            end)
                            if not ok or type(mod) ~= "table" then return end

                            mod._update = function() end
                            local oldNew = mod.new
                            mod.new = function(...)
                                local self = oldNew(...)
                                pcall(function() if self._connection then self._connection:Disconnect() end end)
                                pcall(function() if self._holder then self._holder:Destroy() end end)
                                self._update = function() end
                                self.Clear   = function() end
                                self.Destroy = function() end
                                return self
                            end

                            if type(mod.fromEmitter) == "function" then
                                local oldFrom = mod.fromEmitter
                                mod.fromEmitter = function(...)
                                    local self = oldFrom(...)
                                    pcall(function() if self._connection then self._connection:Disconnect() end end)
                                    pcall(function() if self._holder then self._holder:Destroy() end end)
                                    self._update = function() end
                                    self.Clear   = function() end
                                    self.Destroy = function() end
                                    return self
                                end
                            end
                        end)
                    end
                end
                -------------------- End Emitter Muzzle -----------------------

                ------------------ STRICT Workspace Optimizer -----------------
                local PRESERVE_CAMERA = true
                local CLEAR_TERRAIN   = true
                local Players         = game:GetService("Players")

                local function safeDestroy(inst)
                    if not inst then return end
                    pcall(function() inst:Destroy() end)
                end

                local function addWithAncestors(set, inst)
                    if not inst then return end
                    local cur = inst
                    while cur and cur ~= game do
                        set[cur] = true
                        if cur == workspace then break end
                        cur = cur.Parent
                    end
                end

                local function hasActivationModelChild(inst)
                    if not inst then return false end
                    local act = inst:FindFirstChild("Activation")
                    return act and act:IsA("Model")
                end

                local function collectKeepSets()
                    local keepSubtree, keepAncestors = {}, {}
                    local function keep(inst)
                        if inst then
                            keepSubtree[inst] = true
                            addWithAncestors(keepAncestors, inst)
                        end
                    end

                    -- A) Always keep workspace.Rendered
                    do
                        local rf = workspace:FindFirstChild("Rendered")
                        if not rf then
                            rf = Instance.new("Folder")
                            rf.Name = "Rendered"
                            rf.Parent = workspace
                            warn("[Optimizer] workspace.Rendered not found; created an empty one for safety.")
                        end
                        keep(rf)
                    end

                    -- B) Player characters
                    for _, plr in ipairs(Players:GetPlayers()) do
                        if plr.Character and plr.Character.Parent then
                            keep(plr.Character)
                        end
                    end

                    -- C) Specific paths / teleports / boards / wheels / dealers
                    do
                        local Worlds = workspace:FindFirstChild("Worlds")
                        if Worlds then
                            local over = Worlds:FindFirstChild("The Overworld")
                            if over then keep(over:FindFirstChild("Race")) end

                            for _, world in ipairs(Worlds:GetChildren()) do
                                local areas = world:FindFirstChild("Areas")
                                if areas then
                                    for _, area in ipairs(areas:GetChildren()) do
                                        keep(area:FindFirstChild("IslandTeleport"))
                                        keep(area:FindFirstChild("EventBoard"))
                                    end
                                end
                            end

                            local ss = Worlds:FindFirstChild("Seven Seas")
                            if ss then
                                local areas = ss:FindFirstChild("Areas")
                                if areas then
                                    local bh = areas:FindFirstChild("Blizzard Hills")
                                    if bh then
                                        keep(bh:FindFirstChild("IslandTeleport"))
                                        keep(bh:FindFirstChild("EventBoard"))
                                    end
                                end
                            end
                        end
                    end
                    do
                        local he = workspace:FindFirstChild("HalloweenEvent")
                        if he then
                            keep(he:FindFirstChild("HalloweenWheelSpin"))
                            keep(he:FindFirstChild("ShadyDealer"))
                        end
                    end
                    do
                        local dc = workspace:FindFirstChild("Dark Castle")
                        if dc then keep(dc:FindFirstChild("DarkWheelSpin")) end
                    end

                    -- D) Containers that have child "Activation" (Model)
                    for _, inst in ipairs(workspace:GetDescendants()) do
                        if hasActivationModelChild(inst) then keep(inst) end
                    end

                    -- E) Whitelist names anywhere
                    local WHITELIST_NAMES = {
                        ["IslandTeleport"]=true, ["FestivalQuest"]=true, ["FestivalWheelSpin"]=true,
                        ["FestivalSpin"]=true,   ["Race"]=true,          ["GemGenie"]=true,
                        ["WheelSpin"]=true,      ["SecretBounty"]=true,
                    }
                    for _, inst in ipairs(workspace:GetDescendants()) do
                        if WHITELIST_NAMES[inst.Name] then keep(inst) end
                    end

                    -- F) Ephemeral names scripts often reparent
                    local EPHEMERAL_NAMES = { "Ring", "Display", "Root", "Activation", "Pad", "Counter" }
                    for _, inst in ipairs(workspace:GetDescendants()) do
                        for _, nm in ipairs(EPHEMERAL_NAMES) do
                            if inst.Name == nm then keep(inst) break end
                        end
                    end

                    -- G) Prefix keep: Festival*
                    for _, inst in ipairs(workspace:GetDescendants()) do
                        local n = inst.Name
                        if type(n) == "string" and string.sub(n, 1, #"Festival") == "Festival" then
                            keep(inst)
                        end
                    end

                    return keepSubtree, keepAncestors
                end

                local function deepClean(node, keepSubtree, keepAncestors, activeCamera)
                    if not node then return end
                    for _, ch in ipairs(node:GetChildren()) do
                        if PRESERVE_CAMERA and activeCamera and ch == activeCamera then
                            -- keep camera
                        elseif ch:IsA("Terrain") then
                            if CLEAR_TERRAIN then
                                pcall(function() ch:Clear() end)
                                for _, d in ipairs(ch:GetChildren()) do
                                    safeDestroy(d)
                                end
                            else
                                safeDestroy(ch)
                            end
                        else
                            if keepSubtree[ch] then
                                -- keep subtree
                            elseif keepAncestors[ch] then
                                deepClean(ch, keepSubtree, keepAncestors, activeCamera)
                            else
                                safeDestroy(ch)
                            end
                        end
                    end
                end

                local function optimizeOnce()
                    local activeCamera = nil
                    if PRESERVE_CAMERA then
                        activeCamera = workspace:FindFirstChildOfClass("Camera")
                        if not activeCamera then
                            pcall(function() activeCamera = workspace.CurrentCamera end)
                        end
                    end
                    local keepSubtree, keepAncestors = collectKeepSets()
                    deepClean(workspace, keepSubtree, keepAncestors, activeCamera)
                    local kept = {}
                    for inst, _ in pairs(keepSubtree) do table.insert(kept, inst:GetFullName()) end
                    table.sort(kept)
                    print("[Optimizer STRICT COMBINED] Kept subtrees (" .. tostring(#kept) .. "):")
                    for _, name in ipairs(kept) do print("  - " .. name) end
                end
                ---------------- End STRICT Workspace Optimizer ----------------

                ---------------------- Personal Floor v1 -----------------------
                do
                    if not _G.__PERSONAL_FLOOR_V1__ then
                        _G.__PERSONAL_FLOOR_V1__ = true

                        local Players      = game:GetService("Players")
                        local RunService   = game:GetService("RunService")
                        local UIS          = game:GetService("UserInputService")
                        local LP = Players.LocalPlayer

                        local PF_PAD_SIZE = Vector3.new(14, 1, 14)
                        local PF_PAD_NAME = "PersonalFloor"
                        local PF_PAD_TRANSPARENCY = 0.05
                        local PF_PAD_COLOR = Color3.fromRGB(90, 170, 255)
                        local PF_FOLLOW_LERP_ALPHA = 1.0
                        local PF_HEIGHT_MAX_RATE   = 24
                        local PF_INPUT_RATE        = 32
                        local PF_JUMP_BOOST        = 6
                        local PF_START_OFFSET_BELOW= 4
                        local PF_MIN_TOP_Y, PF_MAX_TOP_Y = -3000, 3000
                        local PF_SHOW_GUI_ON_DESKTOP = true

                        local PF_gui, PF_upHeld, PF_downHeld = nil, false, false
                        local PF_pad, PF_hrp, PF_humanoid
                        local PF_targetTopY, PF_currentTopY
                        local PF_runConn, PF_humConn

                        local function PF_getRenderedParent()
                            local rf = workspace:FindFirstChild("Rendered")
                            if not rf then
                                rf = Instance.new("Folder"); rf.Name = "Rendered"; rf.Parent = workspace
                                warn("[PersonalFloor] workspace.Rendered not found; created one.")
                            end
                            return rf
                        end
                        local function PF_destroy(o) if o and o.Destroy then pcall(function() o:Destroy() end) end end
                        local function PF_createPad()
                            PF_destroy(PF_pad)
                            PF_pad = Instance.new("Part")
                            PF_pad.Name = PF_PAD_NAME
                            PF_pad.Size = PF_PAD_SIZE
                            PF_pad.Anchored = true
                            PF_pad.CanCollide = true
                            PF_pad.CanQuery = true
                            PF_pad.Transparency = PF_PAD_TRANSPARENCY
                            PF_pad.Color = PF_PAD_COLOR
                            PF_pad.Material = Enum.Material.SmoothPlastic
                            PF_pad.TopSurface = Enum.SurfaceType.Smooth
                            PF_pad.BottomSurface = Enum.SurfaceType.Smooth
                            PF_pad.Parent = PF_getRenderedParent()
                        end
                        local function PF_topYToCenterY(topY)
                            return topY - (PF_pad and PF_pad.Size.Y or PF_PAD_SIZE.Y)/2
                        end

                        local function PF_setupGUI()
                            PF_destroy(PF_gui)
                            if not UIS.TouchEnabled and not PF_SHOW_GUI_ON_DESKTOP then return end
                            local pgui = LP:FindFirstChild("PlayerGui") or LP:WaitForChild("PlayerGui")
                            PF_gui = Instance.new("ScreenGui")
                            PF_gui.Name = "PersonalFloorControls"
                            PF_gui.ResetOnSpawn = false
                            PF_gui.IgnoreGuiInset = true
                            PF_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                            PF_gui.Parent = pgui

                            local frame = Instance.new("Frame")
                            frame.AnchorPoint = Vector2.new(1, 0.5)
                            frame.Position    = UDim2.new(1, -20, 0.5, 0)
                            frame.Size        = UDim2.new(0, 68, 0, 140)
                            frame.BackgroundTransparency = 1
                            frame.Parent = PF_gui

                            local function makeBtn(text, yOffset)
                                local b = Instance.new("TextButton")
                                b.Size = UDim2.new(1, 0, 0, 64)
                                b.Position = UDim2.new(0, 0, 0, yOffset)
                                b.Text = text
                                b.TextSize = 36
                                b.Font = Enum.Font.GothamBold
                                b.AutoButtonColor = true
                                b.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
                                b.TextColor3 = Color3.fromRGB(240, 240, 240)
                                b.BorderSizePixel = 0
                                b.Parent = frame
                                local corner = Instance.new("UICorner", b); corner.CornerRadius = UDim.new(0, 14)
                                return b
                            end

                            local upBtn = makeBtn("â²", 0)
                            local dnBtn = makeBtn("â¼", 76)

                            local function hookButton(btn, setter)
                                btn.MouseButton1Down:Connect(function() setter(true) end)
                                btn.MouseButton1Up:Connect(function() setter(false) end)
                                btn.MouseLeave:Connect(function() setter(false) end)
                                btn.TouchLongPress:Connect(function(_, state)
                                    if state == Enum.LongPressState.Begin then setter(true) else setter(false) end
                                end)
                                btn.TouchTap:Connect(function() setter(false) end)
                                btn.InputEnded:Connect(function(input)
                                    if input.UserInputType == Enum.UserInputType.Touch then setter(false) end
                                end)
                            end
                            hookButton(upBtn,   function(v) PF_upHeld   = v; if v then PF_lockToFeet=false; PF_lastManualTime=os.clock() end end)
                            hookButton(dnBtn,   function(v) PF_downHeld = v; if v then PF_lockToFeet=false; PF_lastManualTime=os.clock() end end)
                        end

                        local function PF_keyBindings()
                            UIS.InputBegan:Connect(function(input, gp)
                                if gp then return end
                                if input.KeyCode == Enum.KeyCode.RightBracket then PF_upHeld   = true; PF_lockToFeet=false; PF_lastManualTime=os.clock() end
                                if input.KeyCode == Enum.KeyCode.LeftBracket  then PF_downHeld = true; PF_lockToFeet=false; PF_lastManualTime=os.clock() end
                                if input.KeyCode == Enum.KeyCode.T then
                                    if PF_gui then PF_gui.Enabled = not PF_gui.Enabled end
                                end
                            end)
                            UIS.InputEnded:Connect(function(input, gp)
                                if input.KeyCode == Enum.KeyCode.RightBracket then PF_upHeld   = false end
                                if input.KeyCode == Enum.KeyCode.LeftBracket  then PF_downHeld = false end
                            end)
                        end

                        local function PF_onJump()
                            PF_targetTopY = math.clamp((PF_targetTopY or 0) + PF_JUMP_BOOST, PF_MIN_TOP_Y, PF_MAX_TOP_Y)
                        end
                        local function PF_disconnectConns()
                            if PF_runConn then PF_runConn:Disconnect() PF_runConn = nil end
                            if PF_humConn then PF_humConn:Disconnect() PF_humConn = nil end
                        end
                        local function PF_attach(char)
                            PF_disconnectConns()
                            PF_humanoid = char:WaitForChild("Humanoid")
                            PF_hrp      = char:WaitForChild("HumanoidRootPart")
                            PF_createPad()
                            PF_setupGUI()

                            local hip = PF_humanoid.HipHeight or 2
                            PF_targetTopY  = PF_hrp.Position.Y - (hip + PF_START_OFFSET_BELOW)
                            PF_currentTopY = PF_targetTopY

                            PF_humConn = PF_humanoid.StateChanged:Connect(function(_, new)
                                if new == Enum.HumanoidStateType.Jumping then PF_onJump() end
                            end)

                            local lastT = os.clock()
                            



PF_runConn = RunService.RenderStepped:Connect(function()
    if not PF_pad or not PF_hrp then return end
    local now = os.clock()
    local dt = math.max(1/300, now - lastT)
    lastT = now

    -- Input-aware locking:
    PF_lastManualTime = PF_lastManualTime or 0
    PF_lockToFeet = PF_lockToFeet == nil and true or PF_lockToFeet
    local PF_RELATCH_SEC = 0.4

    -- If user is pressing up/down, go free-mode and remember last manual time.
    if PF_upHeld or PF_downHeld then
        PF_lockToFeet = false
        PF_lastManualTime = now
    elseif (now - PF_lastManualTime) > PF_RELATCH_SEC then
        PF_lockToFeet = true
    end

    local hip = PF_humanoid and PF_humanoid.HipHeight or 2
    local hrpHalf = (PF_hrp and PF_hrp.Size and PF_hrp.Size.Y or 2) * 0.5
    local footTopY = PF_hrp.Position.Y - (hip + hrpHalf)

    if PF_lockToFeet then
        -- EXACT lock: pad top matches foot plane; never pushes.
        PF_currentTopY = footTopY
    else
        -- Manual/free mode: allow moving pad relative to player and teleport snapping.
        local TELEPORT_Y_JUMP = 60
        local desiredTopY = footTopY -- baseline for snap checks

        PF_targetTopY = PF_targetTopY or desiredTopY
        PF_currentTopY = PF_currentTopY or PF_targetTopY

        if math.abs(desiredTopY - PF_targetTopY) > TELEPORT_Y_JUMP then
            PF_targetTopY = desiredTopY
            PF_currentTopY = desiredTopY
        end

        if PF_upHeld   then PF_targetTopY = math.clamp(PF_targetTopY + PF_INPUT_RATE * dt, PF_MIN_TOP_Y, PF_MAX_TOP_Y) end
        if PF_downHeld then PF_targetTopY = math.clamp(PF_targetTopY - PF_INPUT_RATE * dt, PF_MIN_TOP_Y, PF_MAX_TOP_Y) end

        local delta = PF_targetTopY - PF_currentTopY
        local maxStep = (PF_HEIGHT_MAX_RATE or 24) * dt
        if math.abs(delta) <= maxStep then
            PF_currentTopY = PF_targetTopY
        else
            PF_currentTopY = PF_currentTopY + (delta > 0 and maxStep or -maxStep)
        end
    end

    -- Follow player XZ
    local goalXZ = PF_hrp.Position
    local newX = PF_pad.Position.X + (goalXZ.X - PF_pad.Position.X) * PF_FOLLOW_LERP_ALPHA
    local newZ = PF_pad.Position.Z + (goalXZ.Z - PF_pad.Position.Z) * PF_FOLLOW_LERP_ALPHA
    local centerY = PF_topYToCenterY(PF_currentTopY)

    PF_pad.CFrame = CFrame.new(newX, centerY, newZ)
end)

                            char.AncestryChanged:Connect(function(_, parent)
                                if not parent then
                                    PF_disconnectConns()
                                    PF_destroy(PF_pad)
                                end
                            end)
                        end

                        PF_keyBindings()
                        LP.CharacterAdded:Connect(PF_attach)
                        if LP.Character then PF_attach(LP.Character) end
                    end
                end
                -------------------- End Personal Floor v1 ---------------------

                -------------------- Festival Pruner (v2) ---------------------
                do
                    if not _G.__FESTIVAL_PRUNER_V2__ then
                        _G.__FESTIVAL_PRUNER_V2__ = true

                        local function safeWaitForChild(parent, name, timeout)
                            timeout = timeout or 30
                            local elapsed, step = 0, 0.1
                            local obj = parent:FindFirstChild(name)
                            while not obj and elapsed < timeout do
                                task.wait(step); elapsed += step; obj = parent:FindFirstChild(name)
                            end
                            return obj
                        end
                        local function isParticleLike(inst)
                            local n = string.lower(inst.Name or "")
                            if inst:IsA("ParticleEmitter") then return true end
                            if n == "particles" or n == "particle" then return true end
                            return false
                        end
                        local function pruneParticles(root)
                            for _, d in ipairs(root:GetDescendants()) do
                                if isParticleLike(d) then pcall(function() d:Destroy() end) end
                            end
                        end

                        task.spawn(function()
                            local worlds = safeWaitForChild(workspace, "Worlds", 30); if not worlds then return end
                            local overworld = worlds:FindFirstChild("The Overworld") or safeWaitForChild(worlds, "The Overworld", 30); if not overworld then return end
                            local festival = overworld:FindFirstChild("Festival") or safeWaitForChild(overworld, "Festival", 30); if not festival then return end

                            local KEEP = { FestivalPass=true, FestivalQuest=true, FestivalShop=true, FestivalSpin=true }
                            for _, child in ipairs(festival:GetChildren()) do
                                if not KEEP[child.Name] then pcall(function() child:Destroy() end) end
                            end
                            pruneParticles(festival)

                            festival.ChildAdded:Connect(function(child)
                                if not KEEP[child.Name] then
                                    task.defer(function()
                                        if child and child.Parent == festival and not KEEP[child.Name] then
                                            pcall(function() child:Destroy() end)
                                        end
                                    end)
                                end
                            end)
                            festival.DescendantAdded:Connect(function(d)
                                if isParticleLike(d) then
                                    task.defer(function()
                                        if d and d.Parent and d:IsDescendantOf(festival) and isParticleLike(d) then
                                            pcall(function() d:Destroy() end)
                                        end
                                    end)
                                end
                            end)
                        end)
                    end
                end
                ------------------ End Festival Pruner (v2) --------------------

                ---------------- Global Particle Sweeper (v3) ------------------
                
do
    if not _G.__GLOBAL_PARTICLE_SWEEPER_V3__ then
        _G.__GLOBAL_PARTICLE_SWEEPER_V3__ = true

        local Players = game:GetService("Players")
        local LP = Players.LocalPlayer

        -- Kill ONLY ParticleEmitter instances in safe scopes.
        local function isKill(inst)
            return inst:IsA("ParticleEmitter")
        end

        local function sweepRoot(root)
            if not root then return end
            for _, d in ipairs(root:GetDescendants()) do
                if isKill(d) then pcall(function() d:Destroy() end) end
            end
        end

        local function hookRoot(root)
            if not root then return end
            task.defer(function() sweepRoot(root) end)
            root.DescendantAdded:Connect(function(d)
                if isKill(d) then
                    task.defer(function()
                        if d and d.Parent then pcall(function() d:Destroy() end) end
                    end)
                end
            end)
        end

        hookRoot(workspace)
        local pgui = LP and (LP:FindFirstChild("PlayerGui") or LP:WaitForChild("PlayerGui", 5))
        hookRoot(pgui)
        -- NOTE: We intentionally do NOT hook ReplicatedStorage/Assets
        -- to avoid deleting containers like ReplicatedStorage.Assets.Particles.
    end
end
--------------- End Global Particle Sweeper (v3) ---------------

                ------------------ Chunker Coin Killer (v1) --------------------
                do
                    if not _G.__CHUNKER_COIN_KILLER_V1__ then
                        _G.__CHUNKER_COIN_KILLER_V1__ = true
                        local KILL_EXACT = { ["Meshes/bgscoin10"]=true }
                        local function isKillTarget(inst) return inst and KILL_EXACT[inst.Name] == true end
                        local function kill(inst) pcall(function() inst:Destroy() end) end
                        local function sweepRendered(r)
                            if not r then return end
                            for _, d in ipairs(r:GetDescendants()) do
                                if isKillTarget(d) then kill(d) end
                            end
                        end
                        local function hookRendered(r)
                            if not r then return end
                            task.defer(function() sweepRendered(r) end)
                            r.DescendantAdded:Connect(function(d)
                                if isKillTarget(d) then
                                    task.defer(function() if d and d.Parent then kill(d) end end)
                                end
                            end)
                        end
                        local rendered = workspace:FindFirstChild("Rendered")
                        if rendered then hookRendered(rendered) else
                            workspace.ChildAdded:Connect(function(c) if c.Name=="Rendered" then hookRendered(c) end end)
                        end
                    end
                end
                ---------------- End Chunker Coin Killer (v1) ------------------

                ----------------- Chunker Mesh Nuker (v2) ---------------------
                do
                    if not _G.__CHUNKER_MESH_NUKER_V2__ then
                        _G.__CHUNKER_MESH_NUKER_V2__ = true
                        local function lower(s) return type(s)=="string" and string.lower(s) or "" end
                        local function findRendered() return workspace:FindFirstChild("Rendered") end
                        local function isUnderChunker(inst, rendered)
                            if not inst or not rendered then return false end
                            if not inst:IsDescendantOf(rendered) then return false end
                            local p = inst
                            while p and p ~= rendered and p ~= workspace do
                                if string.find(lower(p.Name), "chunker", 1, true) then return true end
                                p = p.Parent
                            end
                            return false
                        end
                        local function targetToDestroy(inst)
                            if inst:IsA("MeshPart") then return inst end
                            if inst:IsA("SpecialMesh") or inst:IsA("BlockMesh") or inst:IsA("CylinderMesh") or inst:IsA("CharacterMesh") then
                                local holder = inst:FindFirstAncestorWhichIsA("BasePart")
                                return holder or inst
                            end
                            return nil
                        end
                        local function nuke(inst) pcall(function() inst:Destroy() end) end
                        local function sweep(rendered)
                            for _, d in ipairs(rendered:GetDescendants()) do
                                local kill = targetToDestroy(d)
                                if kill and isUnderChunker(kill, rendered) then nuke(kill) end
                            end
                        end
                        local function hook(rendered)
                            task.defer(function() sweep(rendered) end)
                            rendered.DescendantAdded:Connect(function(d)
                                local kill = targetToDestroy(d)
                                if kill and isUnderChunker(kill, rendered) then
                                    task.defer(function() if kill and kill.Parent then nuke(kill) end end)
                                end
                            end)
                        end
                        local r = findRendered()
                        if r then hook(r) else
                            workspace.ChildAdded:Connect(function(c) if c.Name=="Rendered" then hook(c) end end)
                        end
                    end
                end
                --------------- End Chunker Mesh Nuker (v2) -------------------

                ---------------------- Run strict pass NOW ---------------------
                optimizeOnce()
                -------------------- End strict pass trigger -------------------

                if WindUI and WindUI.Notify then
                    WindUI:Notify({
                        Title   = "Workspace Optimized",
                        Content = "Strict cleanup done. FX muzzled; pruners & guards running. Check F9 for keep list.",
                        Icon    = "zap",
                        Duration = 6
                    })
                end
            end, function(err)
                if WindUI and WindUI.Notify then
                    WindUI:Notify({ Title="Optimizer Error", Content=tostring(err), Icon="x", Color="Red", Duration=8 })
                else
                    warn("[RcashHub] Optimizer error: " .. tostring(err))
                end
            end)
        end
    })
    -- === End: Workspace Optimizer Button ===


    PerformanceSection:Toggle({
        Flag = "FPSC",
        Title = "FPS Cap (5FPS)",
        Value = false,
        Callback = function(Value)
            if setfpscap then
                if Value then
                    setfpscap(5)
                else
                    setfpscap(1000)
                end
            end
        end
    })

    PerformanceSection:Toggle({
        Flag = "TUIR",
        Title = "Toggle UI Rendering",
        Value = false,
        Callback = function(Value)
            toggleUI(not Value)
        end
    })

    PerformanceSection:Toggle({
        Flag = "T3DR",
        Title = "Toggle 3D Rendering",
        Value = false,
        Callback = function(Value)
            toggleRendering(not Value)
        end
    })

    PerformanceSection:Toggle({
        Flag = "AAFK",
        Title = "Anti-AFK",
        Value = true,
        Callback = function(Value)
            if Value then
                if not antiAFKConnection then
                    antiAFKConnection = player.Idled:Connect(function()
                        pcall(function()
                            VirtualUser:CaptureController()
                            VirtualUser:ClickButton2(Vector2.new())
                        end)
                    end)
                end
            else
                if antiAFKConnection then
                    antiAFKConnection:Disconnect()
                    antiAFKConnection = nil
                end
            end
        end
    })

    -- Quick toggle for AFK mode
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == Enum.KeyCode.L then
            toggleAFKMode(not afkMode)
        end
    end)


    local ConfigManager = Window.ConfigManager
    local ConfigName = "RcashHub_BGSI"

    SettingsTab:Paragraph({
        Title = "Customize Interface",
        Desc = "Personalize your Rcash Hub experience",
        Image = "palette",
        ImageSize = 20,
    })

    local themes = {}
    for themeName, _ in pairs(WindUI:GetThemes()) do
        table.insert(themes, themeName)
    end
    table.sort(themes)

    themeDropdown = SettingsTab:Dropdown({
        Flag = "Theme",
        Title = "Select Theme",
        Values = themes,
        SearchBarEnabled = true,
        MenuWidth = 280,
        Value = WindUI:GetCurrentTheme(),
        Callback = function(theme)
            canChangeDropdown = false
            WindUI:SetTheme(theme)
            canChangeDropdown = true
        end
    })

    darkModeToggle = SettingsTab:Toggle({
        Flag = "DM",
        Title = "Enable Dark Mode",
        Desc = "Use dark color scheme",
        Value = WindUI:GetCurrentTheme() == "Dark",
        Callback = function(state)
            if canChangeTheme then
                WindUI:SetTheme(state and "Dark" or "Light")
                if canChangeDropdown then
                    themeDropdown:Set(state and "Dark" or "Light")
                end
            end
        end
    })

    WindUI:OnThemeChange(function(theme)
        canChangeTheme = false
        if darkModeToggle then
            darkModeToggle:Set(theme == "Dark")
        end
        canChangeTheme = true
    end)

    
    


    SettingsTab:Keybind({
        Flag = "KB",
        Title = "Keybind",
        Desc = "Keybind to open ui",
        Value = "RightControl",
        Callback = function(v)
            Window:SetToggleKey(Enum.KeyCode[v])
        end
    })

    SettingsTab:Space()

_G.RCH_LoadConfig = RCH_loadConfig

    
-- === Config Auto-Save Helpers ===
do
    _G.__RCH_AutoSaveEnabled = (_G.__RCH_AutoSaveEnabled ~= false)

    local function quickDigest()
        local ok, byFlag = pcall(function() return (type(RCH_collectByFlag)=="function") and RCH_collectByFlag() or {} end)
        if not ok or type(byFlag) ~= "table" then return "" end
        local keys = {}
        for k in pairs(byFlag) do table.insert(keys, tostring(k)) end
        table.sort(keys)
        local acc = {}
        for _, flag in ipairs(keys) do
            local elm = byFlag[flag]
            local v = (type(RCH_readElement)=="function") and RCH_readElement(elm) or nil
            table.insert(acc, tostring(flag) .. "=" .. tostring(v))
        end
        -- also include scalar settings
        if _G and _G.Settings and typeof(_G.Settings) == "table" then
            for k, v in pairs(_G.Settings) do
                if typeof(v)=="number" or typeof(v)=="string" or typeof(v)=="boolean" then
                    table.insert(acc, "S:"..tostring(k).."="..tostring(v))
                end
            end
        end
        table.sort(acc)
        return table.concat(acc, "|")
    end

    local lastDigest = nil
    local saving = false

    local function maybeAutoSave()
        if saving or not _G.__RCH_AutoSaveEnabled then return end
        local d = quickDigest()
        if d ~= lastDigest then
            lastDigest = d
            saving = true
            task.spawn(function()
                pcall(function()
                    if _G and _G.__autoSaveConfig then _G.__autoSaveConfig() end
                end)
                saving = false
            end)
        end
    end

    -- run every 5 seconds on a separate thread (not Heartbeat)
    task.spawn(function()
        while true do
            maybeAutoSave()
            task.wait(5)
        end
    end)

    -- expose control
    _G.__RCH_StartAutoSave = function() _G.__RCH_AutoSaveEnabled = true end
    _G.__RCH_StopAutoSave  = function() _G.__RCH_AutoSaveEnabled = false end

    -- start on launch if enabled; no immediate save
    task.defer(function() if _G.__RCH_AutoSaveEnabled then maybeAutoSave() end end)

    -- Save on close/teleport attempts where possible
    task.spawn(function()
        pcall(function()
            game:BindToClose(function()
                if _G and _G.__autoSaveConfig then pcall(_G.__autoSaveConfig) end
            end)
        end)
    end)
end
-- === /Config Auto-Save Helpers ===


-- === Change Hookers (event-driven incremental save) ===
do
    _G.__RCH_Loading = false

    local function markChanged(flag, elm)
        if _G.__RCH_Loading then return end
        local v = (type(RCH_readElement)=="function") and RCH_readElement(elm) or nil
        if v ~= nil and _G.RCH_UpdateOne then
            _G.RCH_UpdateOne(flag, v)
        end
    end

    function _G.RCH_HookChangeHandlers()
        local map = (type(RCH_collectByFlag)=="function") and RCH_collectByFlag() or {}
        for flag, elm in pairs(map) do
            if typeof(elm) == "table" and not rawget(elm, "__RCH_HOOKED") then
                rawset(elm, "__RCH_HOOKED", true)

                -- Wrap Set
                if typeof(elm.Set) == "function" then
                    local old = elm.Set
                    elm.Set = function(self, v, ...)
                        local ret = old(self, v, ...)
                        markChanged(flag, self)
                        return ret
                    end
                end

                -- Wrap Select (dropdowns)
                if typeof(elm.Select) == "function" then
                    local oldSel = elm.Select
                    elm.Select = function(self, v, ...)
                        local ret = oldSel(self, v, ...)
                        markChanged(flag, self)
                        return ret
                    end
                end
            end
        end
    end

    -- Hook once UI is built
    task.defer(function()
        pcall(_G.RCH_HookChangeHandlers)
    end)
end
-- === /Change Hookers ===
local ConfigSection = SettingsTab:Section({
        Title = "Config",
        TextXAlignment = "Left",
        Opened = false,
    })

    local cfgName = "RcashHub_Config"

    ConfigSection:Button({
        Title = "Save Config",
        
        Icon = "save",
        Callback = function()
            local ok = pcall(function()
                local cfg = (Window and Window.ConfigManager) and Window.ConfigManager:CreateConfig(cfgName)
                if cfg and cfg.Save then
                    return cfg:Save()
                end
                if _G and _G.__autoSaveConfig then _G.__autoSaveConfig() end
                return true
            end)
            if WindUI and WindUI.Notify then
                WindUI:Notify({
                    Title = ok and "Config Saved" or "Save Failed",
                    Content = cfgName,
                    Icon = ok and "check" or "x"
                })
            end
        end
    })

    ConfigSection:Button({
        Title = "Load Config",
        
        Icon = "download",
        Callback = function()
            local ok = false
            local okpc = pcall(function()
                if _G and _G.RCH_LoadConfig then ok = _G.RCH_LoadConfig() end
            end)
            ok = ok and okpc
            if WindUI and WindUI.Notify then
                WindUI:Notify({
                    Title = ok and "Config Loaded" or "Load Failed",
                    Content = cfgName,
                    Icon = ok and "check" or "x"
                })

    ConfigSection:Toggle({
        Flag = "AutoSaveConfig",
        Title = "Auto Save Config",
        Value = (_G.__RCH_AutoSaveEnabled ~= false),
        Callback = function(v)
            _G.__RCH_AutoSaveEnabled = v and true or false
            if v and _G.__RCH_StartAutoSave then _G.__RCH_StartAutoSave() end
            if (not v) and _G.__RCH_StopAutoSave then _G.__RCH_StopAutoSave() end
        end
    })

            end
        end
    })




task.defer(function()
    local ok = false
    pcall(function() if _G and _G.RCH_LoadConfig then ok = _G.RCH_LoadConfig() end end)
    if ok and WindUI and WindUI.Notify then
        WindUI:Notify({ Title = "Settings Loaded", Content = "Preferences restored.", Icon = "check", Duration = 2 })
    end
end)
do
    local function _extractHeight(s)
        if extractHeightFromText then
            local ok, h = pcall(extractHeightFromText, s)
            if ok and h then return h end
        end
        local digits = s:match("Height%s*[:%-]?%s*([%d,%.]+)%s*m") or s:match("([%d,%.]+)%s*m")
        if not digits then return nil end
        digits = digits:gsub(",", "")
        local num = tonumber(digits)
        return num and math.floor(num + 0.5) or nil
    end

    function tryParseAndTeleportFromText(text)
        if not AutoTeleport then return end
        local height = _extractHeight(text or "")
        if not height then return end

        local wantedName = (LastSummon and LastSummon.Name) or ""
        local rift = nil
        if findClosestRiftByTypeAndY then
            local ok, a = pcall(findClosestRiftByTypeAndY, wantedName, height)
            if ok then rift = a end
        end
        if not rift then return end

        local hrp = lp and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        local cf = getSpawnCFrame and getSpawnCFrame(rift)
        if hrp and cf then
            if __stopFallbackWatch then pcall(__stopFallbackWatch) end
                hrp.CFrame = cf + Vector3.new(0, 5, 0)
            if _G and _G.StartProximityEForRift then
                _G.StartProximityEForRift(rift, 15, 15, 0.02, 0.005)
            end
            if typeof(WindUI) == "table" and WindUI.Notify then
                pcall(function()
                    WindUI:Notify({ Title = "Teleported to Rift", Description = string.format("%s | Height: %dm", tostring(rift.Name), height), Duration = 5 })
                end)
            end
        end
    end

    local playerGui = lp and (lp:FindFirstChildOfClass("PlayerGui") or lp:FindFirstChild("PlayerGui"))
    if playerGui and not _G.__rift_textlabel_watcher then
        _G.__rift_textlabel_watcher = true

        playerGui.DescendantAdded:Connect(function(desc)
            if desc:IsA("TextLabel") or desc:IsA("TextButton") or desc:IsA("TextBox") then
                desc:GetPropertyChangedSignal("Text"):Connect(function()
                    local t = tostring(desc.Text or "")
                    if t:find("Height") and t:find("m") then
                        task.spawn(function() tryParseAndTeleportFromText(t) end)
                    end
                end)
            end
        end)

        for _, d in ipairs(playerGui:GetDescendants()) do
            if d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox") then
                local t = tostring(d.Text or "")
                if t:find("Height") and t:find("m") then
                    task.spawn(function() tryParseAndTeleportFromText(t) end)
                end
            end
        end
    end
end

    task.spawn(AutoPickupLoop)

end

-- == BEGIN: Rifts Tab (integrated from 'Rifts - make a new rifts tab.lua') ==
do
    -- This block adds a new 'Rifts' tab with Auto Rift Hunter and Rift Spawner sections.
    local RiftsTab = _G.__Tabs.Rifts

----------------------------------------------------------------
-- Shared Data / Helpers (used by both sections)
----------------------------------------------------------------

-- Known Eggs / Chests
local EggNames = {
	"Spikey Egg","Magma Egg","Lunar Egg","Crystal Egg","Void Egg","Hell Egg","Rainbow Egg","Mining Egg","Cyber Egg","Neon Egg","Dev Egg","Pumpkin Egg","Sinister Egg","Costume Egg","Mutant Egg","Puppet Egg"
}
local ChestNames = { "golden-chest","royal-chest","super-chest","dice-rift" }

-- === Rift name mapping (internal <-> display) ===
local RiftDisplayToInternal = {
    ["dev egg"]     = "dev-rift",
    ["pumpkin egg"] = "event-1",
    ["costume egg"] = "event-2",
    ["sinister egg"] = "event-3",
    ["mutant egg"]  = "event-4",
    ["puppet egg"]  = "event-5",
}
local RiftInternalToDisplay = {
    ["dev-rift"] = "Dev Egg",
    ["event-1"]  = "Pumpkin Egg",
    ["event-2"]  = "Costume Egg",
    ["event-3"]  = "Sinister Egg",
    ["event-4"]  = "Mutant Egg",
    ["event-5"]  = "Puppet Egg",
}

local function __norm_key(s)
    s = tostring(s or ""):lower()
    s = s:gsub("[%s%-_]+", " ")
    s = s:match("^%s*(.-)%s*$")
    return s
end

local function toDisplayName(internal)
    internal = tostring(internal or ""):lower()
    return RiftInternalToDisplay[internal] or (internal:gsub("%-"," "):gsub("^%l", string.upper))
end
-- === /Rift name mapping ===
local function toRiftName(name)
    local raw = tostring(name or "")
    local key = __norm_key(raw)
    if RiftDisplayToInternal[key] then return RiftDisplayToInternal[key] end
    local n = string.lower(raw):gsub("%s+", "-")
    if n == "dev-egg" then n = "dev-rift" end
    return n
end

-- === Egg Priorities (global state + helper) ===
-- Keep live handles to the priority dropdowns so loaded config values are reflected
_G.__EggPriorityDropdowns = _G.__EggPriorityDropdowns or {}

local function __GetPriorityChoice(i)
    -- Prefer the actual control's current value (reflects loaded config)
    local dd = _G.__EggPriorityDropdowns and _G.__EggPriorityDropdowns[i]
    if dd and typeof(dd.Get) == "function" then
        local ok, v = pcall(function() return dd:Get() end)
        if ok and v and v ~= "" then return v end
    end
    -- Fallback to our last-cached table (updated via callbacks)
    if __EggPriorities and __EggPriorities[i] and __EggPriorities[i] ~= "" then
        return __EggPriorities[i]
    end
    return ""
end
__EggPriorities = __EggPriorities or { "", "", "", "", "" }
function __GetEggPriorityIndex(rnameNorm)
    if type(__EggPriorities) ~= "table" then return 999 end
    for i = 1, 5 do
        local disp = __GetPriorityChoice(i)
        if disp and disp ~= "" then
            if toRiftName(disp) == rnameNorm then
                return i
            end
        end
    end
    return 999
end



-- Universal spawn finder â robust (from Spawner, with logging trimmed)
local function getSpawnCFrame(rift)
	if not rift then return nil end

	-- Egg rifts
	local eggSpawn = rift:FindFirstChild("EggPlatformSpawn")
	if eggSpawn then
		return eggSpawn.WorldPivot or (eggSpawn.GetPivot and eggSpawn:GetPivot())
	end

	-- Chest rifts
	local chestModel = rift:FindFirstChild("Chest")
	if chestModel then
		return chestModel.WorldPivot or (chestModel.GetPivot and chestModel:GetPivot())
	end

	-- Fallbacks
	for _, name in ipairs({ "ChestPlatformSpawn","Spawn","Platform","Base" }) do
		local part = rift:FindFirstChild(name)
		if part then
			return part.WorldPivot or (part.GetPivot and part:GetPivot())
		end
	end

	if rift.PrimaryPart then
		return rift.PrimaryPart.WorldPivot or (rift.PrimaryPart.GetPivot and rift.PrimaryPart:GetPivot())
	end
	return nil
end

----------------------------------------------------------------
-- === Global E-spammer (safe, reusable) ===
getgenv().__AutoPressE = getgenv().__AutoPressE or { enabled = false }

_G.StartAutoPressE = function(maxSeconds, interval, pulse)
    local state = getgenv().__AutoPressE
    if state.enabled then return end
    state.enabled = true

    local VIM = game:GetService("VirtualInputManager")
    interval = math.clamp(tonumber(interval) or 0.02, 0.005, 0.2)
    pulse    = math.clamp(tonumber(pulse)    or 0.005, 0.003, math.max(interval * 0.5, 0.003))

    local t0 = os.clock()
    task.spawn(function()
        while state.enabled and (not maxSeconds or os.clock() - t0 < maxSeconds) do
            VIM:SendKeyEvent(true, Enum.KeyCode.E, false, game)
            task.wait(pulse)
            VIM:SendKeyEvent(false, Enum.KeyCode.E, false, game)
            task.wait(math.max(0, interval - pulse))
        end
        state.enabled = false
    end)
end

_G.StopAutoPressE = function()
    getgenv().__AutoPressE.enabled = false
end
-- === Proximity E-press manager (15/15, re-enable on re-entry) ===
local Players = game:GetService("Players")

_G.StartProximityEForRift = function(rift, enableDist, disableDist, spamInterval, pulse)
    if not rift or not rift.Parent then return end
    enableDist   = tonumber(enableDist)   or 15   -- ON threshold
    disableDist  = tonumber(disableDist)  or 15   -- OFF threshold
    spamInterval = tonumber(spamInterval) or 0.02
    pulse        = tonumber(pulse)        or 0.005

    -- ensure single watcher per rift
    _G.__ProxWatch = _G.__ProxWatch or setmetatable({}, { __mode = "k" })
    if _G.__ProxWatch[rift] then return end
    _G.__ProxWatch[rift] = true

    local alive = true
    task.spawn(function()
        local lp = Players.LocalPlayer or Players.PlayerAdded:Wait()
        local cooloffUntil = 0

        local function getRiftPivotCF()
            if not (rift and rift.Parent) then return nil end
            if rift.GetPivot then return rift:GetPivot() end
            if typeof(getSpawnCFrame) == "function" then
                local ok, cf = pcall(getSpawnCFrame, rift)
                if ok and cf then return cf end
            end
            if rift.PrimaryPart then return rift.PrimaryPart.CFrame end
            return nil
        end

        while alive and rift.Parent do
            local char = lp.Character
            local hrp  = char and char:FindFirstChild("HumanoidRootPart")
            local cf   = getRiftPivotCF()

            if hrp and cf then
                local dist = (hrp.Position - cf.Position).Magnitude

                -- turn OFF when outside threshold
                if dist >= disableDist then
                    if getgenv().__AutoPressE and getgenv().__AutoPressE.enabled then
                        (_G.StopAutoPressE or function() end)()
                        cooloffUntil = os.clock() + 0.2
                    end
                end

                -- turn ON (and re-enable) when inside threshold
                if dist <= enableDist and os.clock() >= cooloffUntil then
                    if not (getgenv().__AutoPressE and getgenv().__AutoPressE.enabled) then
                        (_G.StartAutoPressE or function() end)(nil, spamInterval, pulse)
                    end
                end
            end

            task.wait(0.05)
        end

        (_G.StopAutoPressE or function() end)()
        _G.__ProxWatch[rift] = nil
    end)

    -- disposer if you ever want to stop manually
    return function() alive = false end
end
-- === /Proximity E-press manager ===



-- convenience wrapper: call whichever exists; no-op if missing
__safeStartE = function(maxSeconds, interval, pulse)
    local f = _G.StartAutoPressE or startAutoPressE
    if f then
        return f(maxSeconds, interval, pulse)
    end
end
-- === End Global E-spammer ===

-- === Emergency Halt for all Rift systems ===
_G.__RiftEmergencyStop = false
_G.HardStopAllRifts = function(reason)
    -- Set global emergency flag so any in-flight teleports abort
    _G.__RiftEmergencyStop = true

    -- Disable hunter and set master flag off
    pcall(function() if SetRiftHunterEnabled then SetRiftHunterEnabled(false) end end)
    -- Stop fallback watcher
    pcall(function() if __stopFallbackWatch then __stopFallbackWatch() end end)
    -- Disable respawn & disconnect watcher
    __AutoRespawnEnabled = false
    pcall(function() if __RespawnDisposer then __RespawnDisposer() end end)
    -- Disable fallback use
    __FallbackEnabled = false

    -- Stop any proximity E spammers
    pcall(function() if _G.StopAutoPressE then _G.StopAutoPressE() end end)
    pcall(function() if _G.StopGlobalE then _G.StopGlobalE() end end)

    -- Try to shut UI toggle for Rift Hunter if we have a handle
    pcall(function()
        if _G.__RiftHunterToggle and _G.__RiftHunterToggle.Set then
            _G.__RiftHunterToggle:Set(false)
        end
    end)

    -- Clear current target if in scope (safe)
    pcall(function()
        if currentTarget then currentTarget = nil end
        if updateInfo then updateInfo() end
    end)

    if WindUI and reason then
        WindUI:Notify({ Title = "Rifts Halted", Content = reason, Duration = 4, Icon = "octagon" })
    end
end
-- === End Emergency Halt ===
----------------------------------------------------------------
-- Section 1: Auto Rift Hunter
----------------------------------------------------------------
do
	local HunterSection = _G.__Rifts_HunterSection
if not HunterSection or type(HunterSection) ~= "table" or not pcall(function() return HunterSection.Paragraph end) then
    HunterSection = RiftsTab:Section({
        Title = "Auto Rift Hunter",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })
    _G.__Rifts_HunterSection = HunterSection
end
    local Players = game:GetService("Players")
    local function getLocalPlayer() return Players.LocalPlayer or Players.PlayerAdded:Wait() end
	HunterSection:Paragraph({
		Title = "Rift Hunter",
		Desc = "Higher luck = Higher Priority. Only switches rifts when a strictly higher-priority rift appears."
	})

	-- State
	local selectedEggs = {}       -- set of normalized rift names we want
	local minLuck = 5             -- min luck (x)
	local scanDelay = 0.5         -- seconds
	local hunterEnabled = false
	local currentTarget = nil     -- {rift=Instance, score=number, name=string, luck=number, timeLeft=number}
__TargetHighestLuck = (__TargetHighestLuck ~= nil) and __TargetHighestLuck or true

-- === Rift Hunter master toggle ===
__RiftHunterEnabled = (__RiftHunterEnabled ~= nil) and __RiftHunterEnabled or false


function SetRiftHunterEnabled(on)
    on = not not on
    __RiftHunterEnabled = on
    if not on then
        if __stopFallbackWatch then pcall(__stopFallbackWatch) end
        pcall(function() if _G.StopGlobalE then _G.StopGlobalE() end end)
        if currentTarget then currentTarget = nil; pcall(function() if updateInfo then updateInfo() end end) end
    end
    if on then
        _G.__RiftEmergencyStop = false
        pcall(function()
            if _G.__StartRiftHunterLoop then _G.__StartRiftHunterLoop() end
        end)
    end

end
	local lastTeleportedRift = nil

	local infoText = HunterSection:Paragraph({ Title = "Current Target", Desc = "None" })

    -- safer + more exact TP with short retries and type-based Y offset
    local function safeTeleportToRift(rift)
        if _G.__RiftEmergencyStop then return end
        if not rift or not rift.Parent then return end

        if __stopFallbackWatch then pcall(__stopFallbackWatch) end

        -- up to ~1s of retries to allow character and rift parts to exist
        local hrp, cf
        for i = 1, 10 do
            local lp = getLocalPlayer()
            local char = lp and lp.Character or nil
            hrp = (char and char:FindFirstChild("HumanoidRootPart")) or hrp
            cf  = cf or getSpawnCFrame(rift)
            if hrp and cf then break end
            task.wait(0.1)
        end
        if not (hrp and cf) then return end

        -- Type-based lift: prefer model hints, fall back to name
        local isChest = (rift:FindFirstChild("Chest") ~= nil)
        if not isChest then
            local n = string.lower(rift.Name or "")
            isChest = n:find("chest") ~= nil or n == "dice-rift"
        end
        local yOffset = isChest and 15 or 5

        hrp.CFrame = cf + Vector3.new(0, yOffset, 0)
        _G.StartProximityEForRift(rift, 15, 15, 0.02, 0.005)
        lastTeleportedRift = rift
        
    end


	local function readLuckFromRift(rift)
		local display = rift:FindFirstChild("Display")
		if not display then return 0 end
		local gui = display:FindFirstChild("SurfaceGui")
		if not gui then return 0 end
		local icon = gui:FindFirstChild("Icon")
		if not icon then return 0 end
		local lbl = icon:FindFirstChild("Luck")
		if not lbl or type(lbl.Text) ~= "string" then return 0 end
		local txt = tostring(lbl.Text or "")
		local digits = txt:match("([%d,%.]+)")
		digits = digits and digits:gsub(",", "") or nil
		return tonumber(digits) or 0
	end

	local function getRemainingTime(rift)
		if not rift then return 0 end
		local display = rift:FindFirstChild("Display")
		if not display then return 0 end
		local gui = display:FindFirstChildOfClass("SurfaceGui")
		if not gui then return 0 end

		local timerLabel
		for _, d in ipairs(gui:GetDescendants()) do
			if d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox") then
				if d.Text and d.Text:find("minute") or d.Text:find("second") or d.Text:find("m") or d.Text:find("s") then
					timerLabel = d
					break
				end
			end
		end
		if not timerLabel or type(timerLabel.Text) ~= "string" then
			return 0
		end

		local text = timerLabel.Text:lower()
		if text == "" or text:find("expired") then
			return 0
		end

		-- "2 minutes 10 seconds"
		local m, s = text:match("(%d+)%s*minute[s]?%s*(%d+)%s*second[s]?")
		if m and s then
			return tonumber(m) * 60 + tonumber(s)
		end

		local mOnly = text:match("(%d+)%s*minute")
		if mOnly then
			return tonumber(mOnly) * 60
		end

		local sOnly = text:match("(%d+)%s*second")
		if sOnly then
			return tonumber(sOnly)
		end

		-- "3m 12s" / "45s"
		local m2, s2 = text:match("(%d+)m%s*(%d+)s")
		if m2 and s2 then
			return tonumber(m2) * 60 + tonumber(s2)
		end
		local s3 = text:match("(%d+)s")
		if s3 then
			return tonumber(s3)
		end

		return 0
	end

	local function isEggSelected(riftName)
		return selectedEggs[riftName] == true
	end

	-- Scoring
	local function scoreRift(rift)
		if not rift then return nil end
		local rname = toRiftName(rift.Name)
		local luck = readLuckFromRift(rift)
		local timeLeft = getRemainingTime(rift)

		if timeLeft <= 10 then
			
			return nil
		end
		if luck < minLuck then
			
			return nil
		end
		if not isEggSelected(rname) then
			
			return nil
		end

		local prio = __GetEggPriorityIndex(rname)
		if __TargetHighestLuck then
			local score = (luck * 1000000000) + ((1000 - prio) * 10) + math.min(timeLeft or 0, 999)
			
			return score, rname, luck, timeLeft, prio
		else
			
			return luck, rname, luck, timeLeft, prio
		end
	end

	local function updateInfo()
		if currentTarget then
            local dispName = toDisplayName(currentTarget.name or "")
			infoText:SetDesc(string.format(
				"%s | Luck %dx | â¦%ds left",
				dispName,
				currentTarget.luck,
				math.max(0, currentTarget.timeLeft or 0),
				currentTarget.score
			))
		else
			infoText:SetDesc("None")
		end
	end
    -- === Fallback TP helper (called by scanOnce) ===
    local __LastFallbackTpAt = 0

    local function __resolveFallbackPosition(choice)
        if not choice or choice == "" then return nil end
        if choice == "__FARMING_EGG__" or choice == "Farming Egg" then
            return _G.FarmingEggPosition
        end
        return EggCoordinates and EggCoordinates[choice]
    end

    function __ensureNearFallbackOnce(choice)
        local pos = __resolveFallbackPosition(choice)
        if not pos then return end

        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local dist = (hrp.Position - pos).Magnitude
        local now = os.clock()

        -- Only TP if we drifted away AND we haven't teleported recently
        if dist > 25 and (now - __LastFallbackTpAt) > 8 then
            __LastFallbackTpAt = now
            hrp.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
            if WindUI then
                WindUI:Notify({
                    Title = "Rcash Hub ",
                    Content = "Moved near fallback egg",
                    Duration = 2,
                    Icon = "navigation",
                })
            end
        end
    end

	local function scanOnce()
		local riftFolder = workspace:FindFirstChild("Rendered")
			and workspace.Rendered:FindFirstChild("Rifts")
		if not riftFolder then
			
			return
		end

		

		-- Step 1: Gather best available target
		local best = nil

		for _, rift in ipairs(riftFolder:GetChildren()) do
			local score, nameNorm, luck, timeLeft, prio = scoreRift(rift)
			if score then
				if not best then
					best = { rift = rift, score = score, name = nameNorm, luck = luck, timeLeft = timeLeft, prio = prio }
				else
					if __TargetHighestLuck then
						if (luck > best.luck)
							or (luck == best.luck and (prio or 999) < (best.prio or 999))
							or (luck == best.luck and (prio or 999) == (best.prio or 999) and (timeLeft or 0) > (best.timeLeft or 0)) then
							best = { rift = rift, score = score, name = nameNorm, luck = luck, timeLeft = timeLeft, prio = prio }
						end
					else
						if score > (best.score or -1) then
							best = { rift = rift, score = score, name = nameNorm, luck = luck, timeLeft = timeLeft, prio = prio }
						end
					end
				end
			end
		end

-- Step 2: Handle despawned or expired current target
		local currentExpired = false
		if currentTarget then
			if not currentTarget.rift or not currentTarget.rift.Parent then
				currentExpired = true
				
			elseif getRemainingTime(currentTarget.rift) <= 10 then
				currentExpired = true
				
			end
		end

		-- Step 3: Decide whether to switch
		if best then
			local shouldSwitch = false

			if not currentTarget or currentExpired then
				shouldSwitch = true
			else
				if __TargetHighestLuck then
					local curLuck = currentTarget.luck or 0
					local curPrio = __GetEggPriorityIndex(currentTarget.name or "")
					if (best.luck > curLuck)
						or (best.luck == curLuck and (best.prio or 999) < (curPrio or 999))
						or (best.luck == curLuck and (best.prio or 999) == (curPrio or 999) and (best.timeLeft or 0) > (currentTarget.timeLeft or 0)) then
						shouldSwitch = true
					end
				else
					if best.rift ~= currentTarget.rift and (best.score or -1) > (currentTarget.score or -1) then
						shouldSwitch = true
					end
				end
			end
			if shouldSwitch then
				currentTarget = best
				lastTeleportedRift = nil
				
				updateInfo()
				if __stopFallbackWatch then pcall(__stopFallbackWatch) end
				task.defer(function()
					safeTeleportToRift(best.rift)
				end)
			else
				
			end

		else
			if currentTarget then
				
				currentTarget = nil
				updateInfo()
			end
            if __FallbackEnabled then
                local chosen = __HunterFallback.egg
                if (not chosen or chosen == "") then
                    chosen = __HunterLastSelectedEgg or (EggNames and EggNames[1])
                end
                __startFallbackWatch(chosen)
                pcall(function() __ensureNearFallbackOnce(chosen) end)
            end
		end
	end

	local function hunterLoop()
		while hunterEnabled and __RiftHunterEnabled do
			task.spawn(scanOnce)
			task.wait(math.max(0.25, scanDelay))
		end
	end
    
	-- Expose a global starter so other modules (like Egg TP) can restart the loop after a pause.
	_G.__StartRiftHunterLoop = function()
		-- Clear emergency if the user explicitly wants hunter running again
		_G.__RiftEmergencyStop = false
		if hunterEnabled and __RiftHunterEnabled then
			task.spawn(hunterLoop)
		end
	end


	-- Live info updater
	task.spawn(function()
		while true do
			task.wait(1)
			if hunterEnabled and currentTarget and currentTarget.rift and currentTarget.rift.Parent then
				local newTime = getRemainingTime(currentTarget.rift)
				if newTime and newTime > 0 then
					currentTarget.timeLeft = newTime
					updateInfo()
				end
			end
		end
	end)

	-- UI Controls (inside Section)
	HunterSection:Dropdown({
	    Flag = "EggsToHunt",
		Title = "Eggs to Hunt",
		Values = EggNames,
		Value = {},
		Multi = true,
		Callback = function(vals)
			__HunterLastSelectedEgg = (type(vals)=="table" and vals[1]) or __HunterLastSelectedEgg

			selectedEggs = {}
			for _, v in ipairs(vals) do
				selectedEggs[toRiftName(v)] = true
			end
			if currentTarget and not isEggSelected(currentTarget.name) then
				currentTarget = nil
				updateInfo()
			end
		end
	})

    HunterSection:Slider({
        Flag = "MinimumLuck",
        Title = "Minimum Luck",
        Step = 5,
        Value = { Min = 5, Max = 25, Default = minLuck or 5 },
        Display = function(v)
            return string.format("%dx", v)
        end,
        Callback = function(v)
            v = tonumber(v) or 5
            v = math.clamp(v, 5, 25)
            minLuck = v - (v % 5)
        end
    })
HunterSection:Toggle({
    Flag = "TargetHighestLuck",
    Title = "Target Highest Luck Rift",
    Value = (__TargetHighestLuck ~= nil) and __TargetHighestLuck or true,
        Callback = function(v) __TargetHighestLuck = not not v end
})

local riftHunterToggle = HunterSection:Toggle({
	    Flag = "EnableRiftHunter",
		Title = "Enable Rift Hunter",
		Value = false,
        Callback = function(v)
            hunterEnabled = v
            SetRiftHunterEnabled(v)

            if v then
                _G.__RiftEmergencyStop = false
WindUI:Notify({ Title = "Rift Hunter", Content = "Enabled", Duration = 3 })
_G.__RiftHunterToggle = riftHunterToggle

                task.spawn(hunterLoop)
            else
                WindUI:Notify({ Title = "Rift Hunter", Content = "Disabled", Duration = 3 })
                if __stopFallbackWatch then pcall(__stopFallbackWatch) end
                (_G.StopAutoPressE or function() end)()
            end
        end
	})
end
----------------------------------------------------------------
-- Section 2: Rcash Rift Spawner â PATCHED (keeps old logic)
----------------------------------------------------------------
do
local SpawnerSection = RiftsTab:Section({
        Title = "Rift Spawner",
        TextXAlignment = "Left",
        TextSize = 17,
        Opened = false,
    })

    SpawnerSection:Paragraph({
        Title = "Summon Rift",
        Desc = "Spawn any Egg or Chest Rift with custom duration. Luck only applies to Eggs."
    })
    local TimeLabels = { [1]="10m",[2]="15m",[3]="20m",[4]="25m",[5]="30m" }
    local LuckLabels = { [1]="5x",[2]="10x",[3]="15x",[4]="20x",[5]="25x" }

    local function valueToIndex(val, base, step)
        local idx = math.floor((val - base + (step/2)) / step) + 1
        return math.clamp(idx, 1, 5)
    end
    local function indexToValue(idx, base, step)
        return base + (math.clamp(idx,1,5)-1)*step
    end

    local function autoWorld(name, isEgg)
        local lname = string.lower(tostring(name))

        if isEgg then
            local paradiseEggs = { ["mining egg"]=true, ["cyber egg"]=true, ["neon egg"]=true }
            return paradiseEggs[lname] and "Minigame Paradise" or "The Overworld"
        else
            if lname == "dice-rift" or lname == "dice rift" then
                return "Minigame Paradise"
            end
            return "The Overworld"
        end
    end
    local function __getRiftRemoteFunction(timeout)
        timeout = tonumber(timeout) or 6
        local RS = game:GetService("ReplicatedStorage")

        -- If already captured and usable, reuse it.
        if RemoteFunction and RemoteFunction.InvokeServer then
            return RemoteFunction
        end

        -- Primary path (your original) with waits
        local okPath, rf = pcall(function()
            local shared = RS:WaitForChild("Shared", timeout)
            local fw     = shared and shared:WaitForChild("Framework", timeout)
            local net    = fw and fw:WaitForChild("Network", timeout)
            local remote = net and net:WaitForChild("Remote", timeout)
            return remote and remote:WaitForChild("RemoteFunction", timeout)
        end)
        if okPath and rf then
            RemoteFunction = rf
            return rf
        end

        -- Deep search fallback
        local found = RS:FindFirstChild("RemoteFunction", true)
        if found and found.InvokeServer then
            RemoteFunction = found
            return found
        end

        -- Module adapter fallback
        local okMod, RemoteModule = pcall(function()
            return require(RS.Shared.Framework.Network.Remote)
        end)
        if okMod and RemoteModule and RemoteModule.Invoke then
            local adapter = { InvokeServer = function(_, ...) return RemoteModule.Invoke(...) end }
            RemoteFunction = adapter
            return adapter
        end

        return nil
    end

    local function __summonRiftInvoke(payload)
        local rf = __getRiftRemoteFunction(6)
        if not rf then
            warn("[Rcash-Rift] RemoteFunction not found â cannot summon in this server/build.")
            if WindUI then
                WindUI:Notify({ Title="Rift Summon", Content="â RemoteFunction not found here.", Duration=5 })
            end
            return nil
        end
        return rf:InvokeServer("SummonRift", payload)
    end

    ----------------------------------------------------------------
    -- Popup watcher (your old auto-TP behavior, kept but made sturdier)
    ----------------------------------------------------------------
    local LastSummon = nil
    local AutoTeleport = true

    task.spawn(function()
        local RunService = game:GetService("RunService")
        if not RunService:IsClient() then return end
        local Players = game:GetService("Players")
        local lp = Players.LocalPlayer or Players.PlayerAdded:Wait()
        if not lp then return end
        local playerGui = lp:FindFirstChildOfClass("PlayerGui") or lp:WaitForChild("PlayerGui", 10)
        if not playerGui then return end

        local function tryParseAndTeleportFromText(text)
            if not AutoTeleport then return end
            local height = extractHeightFromText(text)
            if not height then return end
            task.wait(1.0) -- give time for world to place parts
            local rift = select(1, findClosestRiftByTypeAndY(LastSummon and LastSummon.Name or "", height))
            if not rift then return end
            local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
            local cf = getSpawnCFrame(rift)
            if hrp and cf then
                if __stopFallbackWatch then pcall(__stopFallbackWatch) end
                hrp.CFrame = cf + Vector3.new(0, 5, 0)
                _G.StartProximityEForRift(rift, 15, 15, 0.02, 0.005)
                if WindUI then
                    WindUI:Notify({ Title="Teleported to Rift", Content=string.format("%s | Height: %dm", rift.Name, height), Duration=5 })
                end
            end
        end

        -- Watch future GUI text updates
        playerGui.DescendantAdded:Connect(function(desc)
            if desc:IsA("TextLabel") or desc:IsA("TextButton") or desc:IsA("TextBox") then
                desc:GetPropertyChangedSignal("Text"):Connect(function()
                    local t = tostring(desc.Text or "")
                    if t:find("Height") and t:find("m") then
                        tryParseAndTeleportFromText(t)
                    end
                end)
            end
        end)

        -- Scan existing labels once (old code used to miss these)
        for _, d in ipairs(playerGui:GetDescendants()) do
            if (d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox")) and type(d.Text)=="string" then
                local t = d.Text
                if t:find("Height") and t:find("m") then
                    tryParseAndTeleportFromText(t)
                end
            end
        end
    end)
    
    ----------------------------------------------------------------
    -- Fallback Eggs (global control for both Hunter & Spawner)
    ----------------------------------------------------------------
    do
        
    ----------------------------------------------------------------
    -- Egg Priorities (tie-breaker when luck is equal)
    ----------------------------------------------------------------
    do
        local PrioritySection = RiftsTab:Section({
            Title = "Egg Priorities",
            TextXAlignment = "Left",
            TextSize = 17,
            Opened = false,
        })

        local function _priorityValues()
            local vals = {}
            if type(__getFallbackEggList)=="function" then
                local t = __getFallbackEggList()
                if type(t)=="table" then for _,v in ipairs(t) do table.insert(vals, v) end end
            end
            for _,v in ipairs(EggNames or {}) do
                local found = false
                for _,w in ipairs(vals) do if w == v then found = true break end end
                if not found then table.insert(vals, v) end
            end
            local hasDev = false
            for _,v in ipairs(vals) do if string.lower(v)=="dev egg" then hasDev = true break end end
            if not hasDev then table.insert(vals, "Dev Egg") end
            table.sort(vals)
            return vals
        end

        for i = 1, 5 do
            local __dd = PrioritySection:Dropdown({
                Flag = "EggPriority"..i,
                Title = "Priority "..i,
                Values = _priorityValues(),
                Value = (__EggPriorities and __EggPriorities[i]) or "",
                Multi = false,
                Callback = function(choice)
                    __EggPriorities = __EggPriorities or { "","","","","" }
                    __EggPriorities[i] = choice or ""
                end
            })
            _G.__EggPriorityDropdowns[i] = __dd
        end
    end
local FallbackSection = RiftsTab:Section({
            Title = "Fallback Eggs",
            TextXAlignment = "Left",
            TextSize = 17,
            Opened = false,
        })

        FallbackSection:Toggle({
            Flag = "FallbackEnabled",
            Title = "Use Fallback Eggs",
            Value = __FallbackEnabled or false,
        Callback = function(v) __FallbackEnabled = v and true or false end
        })

        FallbackSection:Toggle({
    Flag = "UseFarmEggFallback",
    Title = "Use Farming Egg as Fallback",
    Value = __UseFarmingFallback or false,
        Callback = function(v)
        __UseFarmingFallback = v and true or false
        if __UseFarmingFallback and not _G.FarmingEggPosition then
            WindUI:Notify({ Title = "Rcash Hub", Content = "No Farming Egg set yet. Use âSet Farming Eggâ in Auto Farming.", Duration = 5, Icon = "map-pin-off" })
        end
    end
})

FallbackSection:Dropdown({
            Flag = "HunterFallbackEgg",
            Title = "Hunter Fallback Egg",
            Values = (function()
                if type(__getFallbackEggList)=="function" then
                    local t = __getFallbackEggList()
                    if type(t)=="table" and #t>0 then return t end
                end
                return EggNames or {}
            end)(),
            Value = __HunterFallback and __HunterFallback.egg or "",
            Multi = false,
        Callback = function(v)
                __HunterFallback = __HunterFallback or {}
                __HunterFallback.egg = v
            end
        })

        FallbackSection:Dropdown({
            Flag = "SpawnerFallbackEgg",
            Title = "Spawner Fallback Egg",
            Values = (function()
                if type(__getFallbackEggList)=="function" then
                    local t = __getFallbackEggList()
                    if type(t)=="table" and #t>0 then return t end
                end
                return EggNames or {}
            end)(),
            Value = __SpawnerFallback and __SpawnerFallback.egg or "",
            Multi = false,
        Callback = function(v)
                __SpawnerFallback = __SpawnerFallback or {}
                __SpawnerFallback.egg = v
            end
        })
    end
    local function summonRift(isEgg, name, timeIndex, luckIndex)
        local world = autoWorld(name, isEgg)
        local payload = { Type = isEgg and "Egg" or "Chest", Name = name, Time = timeIndex, World = world }
        if isEgg then payload.Luck = luckIndex end

        

        local ok, result = pcall(function()
            return __summonRiftInvoke(payload)
        end)

        if WindUI then
            WindUI:Notify({
                Title = ok and "Rift Summoned" or "Summon Failed",
                Content = ok
                    and string.format("%s (%s%s)", name, TimeLabels[timeIndex], isEgg and (", Luck "..LuckLabels[luckIndex]) or "")
                    or ("Could not summon: "..tostring(result)),
                Duration = 4
            })
        end
        if not ok then return end

        if AutoTeleport then
            LastSummon = {
                Name = name,
                IsEgg = isEgg,
                LuckLabel = isEgg and LuckLabels[luckIndex] or nil,
                TimeLabel = TimeLabels[timeIndex],
                Timestamp = os.clock(),
            }

            task.spawn(function()
                local folder = workspace:WaitForChild("Rendered", 5)
                folder = folder and folder:WaitForChild("Rifts", 5)
                if not folder then return end

                local expected = string.lower(toRiftName(name))
                local conn
                local deadline = os.clock() + 6

                local function tryTeleport(rift)
                    if _G.__RiftEmergencyStop then if conn then conn:Disconnect() end return end
                    if not rift or not rift.Parent then return end
                    task.wait(0.25)
                    local lp = game.Players.LocalPlayer
                    local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
                    local cf = getSpawnCFrame(rift)
                    if hrp and cf then
                        local yOffset = (string.find(string.lower(rift.Name), "chest") and 15 or 5)
                        hrp.CFrame = cf + Vector3.new(0, yOffset, 0)
                        _G.StartProximityEForRift(rift, 15, 15, 0.02, 0.005)
                        if WindUI then
                            WindUI:Notify({ Title="Teleported to Rift", Content=rift.Name, Duration=5 })
                        end
                    end
                    if conn then conn:Disconnect() end
                end

                for _, r in ipairs(folder:GetChildren()) do
                    if string.lower(r.Name) == expected then
                        tryTeleport(r)
                        return
                    end
                end

                conn = folder.ChildAdded:Connect(function(child)
                    if os.clock() > deadline then if conn then conn:Disconnect() end return end
                    if string.lower(child.Name) == expected then
                        tryTeleport(child)
                    end
                end)

                while os.clock() < deadline do task.wait(0.1) end
                if conn then conn:Disconnect() end
            end)
        end

        __attachRiftLifecycleWatcher(toRiftName(name), function()
            if __AutoRespawnEnabled then
                local isEggAgain = table.find(EggNames, name) ~= nil
                summonRift(isEggAgain, name, timeIndex, luckIndex)
                return
            end

            if __RiftHunterEnabled and __FallbackEnabled then
                local chosen = (__SpawnerFallback and __SpawnerFallback.egg) or nil

                if (not chosen or chosen == "") and table.find(EggNames, name) ~= nil then
                    chosen = name
                end

                if not chosen or chosen == "" then
                    local list = (type(__getFallbackEggList) == "function") and __getFallbackEggList() or nil
                    chosen = (list and list[1]) or nil
                end

                if chosen and chosen ~= "" then
                    if type(__startFallbackWatch) == "function" then pcall(__startFallbackWatch, chosen) end
                    if type(__ensureNearFallbackOnce) == "function" then pcall(__ensureNearFallbackOnce, chosen) end
                end
            else
                if type(__stopFallbackWatch) == "function" then pcall(__stopFallbackWatch) end
            end
        end)


    end
    local AllRifts = {}
    for _, n in ipairs(EggNames) do table.insert(AllRifts, n) end
    for _, n in ipairs(ChestNames) do table.insert(AllRifts, n) end

    local RiftCfg = { Name = AllRifts[1], TimeIndex = 1, LuckIndex = 1 }
    local LuckSlider

    local RiftDropdown = SpawnerSection:Dropdown({
        Flag = "Rift",
        Title = "Rift Type",
        Values = AllRifts,
        Value = RiftCfg.Name,
        Multi = false,
        Callback = function(v)
            RiftCfg.Name = v
            local isEgg = table.find(EggNames, v)
            if LuckSlider and LuckSlider.SetVisible then
                LuckSlider:SetVisible(isEgg ~= nil)
            end
        end
    })

    local TimeSlider = SpawnerSection:Slider({
        Flag = "Time",
        Title = "Rift Duration",
        Step = 5,
        Value = { Min = 10, Max = 30, Default = indexToValue(RiftCfg.TimeIndex, 10, 5) },
        Display = function(v)
            local idx = valueToIndex(v, 10, 5)
            return TimeLabels[idx]
        end,
        Callback = function(v)
            RiftCfg.TimeIndex = valueToIndex(v, 10, 5)
        end
    })

    LuckSlider = SpawnerSection:Slider({
        Flag = "Luck",
        Title = "Rift Luck",
        Step = 5,
        Value = { Min = 5, Max = 25, Default = indexToValue(RiftCfg.LuckIndex, 5, 5) },
        Display = function(v)
            local idx = valueToIndex(v, 5, 5)
            return LuckLabels[idx]
        end,
        Callback = function(v)
            RiftCfg.LuckIndex = valueToIndex(v, 5, 5)
        end
    })

    SpawnerSection:Toggle({
        Flag = "AutoTeleportToRift",
        Title = "Auto Teleport to Rift",
        Value = AutoTeleport,
        Callback = function(v)
            AutoTeleport = v
        end
    })

    SpawnerSection:Toggle({
        Flag = "AutoRespawnRift",
        Title = "Auto Spawn Rift (respawn on despawn)",
        Value = __AutoRespawnEnabled,
        Callback = function(v)
            __AutoRespawnEnabled = v
            if not v and __RespawnDisposer then __RespawnDisposer() __RespawnDisposer = nil end
        end
    })
    -- >>> END PATCH
SpawnerSection:Button({
        Title = "Summon Rift",
        
        Icon = "zap",
        Callback = function()
            local isEgg = table.find(EggNames, RiftCfg.Name) ~= nil
            summonRift(isEgg, RiftCfg.Name, RiftCfg.TimeIndex, RiftCfg.LuckIndex)
        end
    })
end





end
local MinigamesTab = _G.__Tabs.Minigames

--== Libraries & UI Setup ==--
local RdotAicons = { logo = "rbxassetid://90433023359064" }

--== Tab ==--
local Section = MinigamesTab:Section({ Title = "Auto Dice", TextXAlignment = "Left", TextSize = 17, Opened = false })
--== Default Config ==--
local Config = {
    AutoBoardGame = false,
    DICE_TYPE = "Dice",
    GOLDEN_DICE_DISTANCE = 4,
    DelayForChanceTile = 0,
    Verbose = true,
    TILES_TO_TARGET = {}
}
getgenv().BoardAutoDiceConfig = Config

--== Services / Game Refs ==--
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local BoardUtil = require(ReplicatedStorage.Shared.Utils.BoardUtil)
local RemoteFunction = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteFunction
local RemoteEvent = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent

--== Utils ==--
local function log(...)
    if Config.Verbose then
        
    end
end

local function safeWait(t)
    task.wait((t and t > 0) and t or 0.3)
end

--== Stats ==--
local Stats = {
    TotalRolls = 0,
    GoldenDiceUses = 0,
    TargetHits = {}, -- [tileType] = count
}

local function resetStats()
    Stats.TotalRolls = 0
    Stats.GoldenDiceUses = 0
    Stats.TargetHits = {}
end

local function incrementTargetHit(tileType)
    if not tileType then return end
    Stats.TargetHits[tileType] = (Stats.TargetHits[tileType] or 0) + 1
end

local function formatTargetHits()
    local parts = {}
    for tileType, count in pairs(Stats.TargetHits) do
        table.insert(parts, string.format("%s: %d", tileType, count))
    end
    if #parts == 0 then
        return "No target tiles hit yet."
    end
    return table.concat(parts, " | ")
end

--== Core Logic ==--
local function takeTurn(diceType)
    log("Rolling with:", diceType)
    local success, rollResponse = pcall(function()
        return RemoteFunction:InvokeServer("RollDice", diceType)
    end)

    if success and rollResponse then
        Stats.TotalRolls += 1
        if diceType == "Golden Dice" then
            Stats.GoldenDiceUses += 1
        end

        log(("  > Success! Rolled: %s ; Dest Tile: %s"):format(
            tostring(rollResponse.Roll),
            tostring(rollResponse.Tile and rollResponse.Tile.Index)
        ))

        local expectedTile = rollResponse.Tile and rollResponse.Tile.Index
        local moveCompleted = false
        local timeout = 5
        local startTime = tick()

        while tick() - startTime < timeout do
            task.wait(0.1)
            local currentTile = LocalPlayer:GetAttribute("BoardIndex")
            if currentTile == expectedTile then
                log("  > Landing confirmed at Tile", currentTile)
                moveCompleted = true
                break
            end
        end

        if moveCompleted then
            local landedTileInfo = expectedTile and BoardUtil.Nodes[expectedTile]
            local tileType = landedTileInfo and landedTileInfo.Type or "?"
            log(("  > Claiming tile reward (%s)..."):format(tileType))
            RemoteEvent:FireServer("ClaimTile")

            if tileType and Config.TILES_TO_TARGET[tileType] then
                incrementTargetHit(tileType)
            end

            safeWait(0.2)
            return rollResponse
        else
            log("  > Landing FAILED: timed out waiting for BoardIndex to update.")
            return nil
        end
    else
        log("  > Roll failed or was rejected.")
        safeWait(0.2)
        return nil
    end
end

--== Main Loop ==--
local Running = false

local function mainLoop(updateStatsUI)
    if Running then return end
    Running = true
    resetStats()
    log("Auto-Dice loop: STARTED")

    while Config.AutoBoardGame do
        local currentTileNumber = LocalPlayer:GetAttribute("BoardIndex")
        if not currentTileNumber then
            log("Waiting for player to be on the board...")
            task.wait(2)
            continue
        end

        local totalTiles = #BoardUtil.Nodes
        local actionTaken = false
        local turnResponse = nil

        log("---")
        log("Current Tile:", currentTileNumber)

        -- Golden Dice snipe logic
        for i = 1, Config.GOLDEN_DICE_DISTANCE do
            local nextTileIndex = currentTileNumber + i
            if nextTileIndex > totalTiles then nextTileIndex = nextTileIndex - totalTiles end
            local tileInfo = BoardUtil.Nodes[nextTileIndex]
            if tileInfo and Config.TILES_TO_TARGET[tileInfo.Type] then
                log(("Target '%s' found %d tiles ahead! Using Golden Dice..."):format(tileInfo.Type, i))
                for _ = 1, i do
                    turnResponse = takeTurn("Golden Dice")
                    updateStatsUI()
                    if not turnResponse then break end
                end
                actionTaken = true
                break
            end
        end

        -- Regular Dice chance logic
        if not actionTaken then
            local maxRoll = (Config.DICE_TYPE == "Dice" and 6 or 10)
            for i = 1, maxRoll do
                local nextTileIndex = currentTileNumber + i
                if nextTileIndex > totalTiles then nextTileIndex = nextTileIndex - totalTiles end
                local tileInfo = BoardUtil.Nodes[nextTileIndex]
                if tileInfo and Config.TILES_TO_TARGET[tileInfo.Type] then
                    log(("Target '%s' found in range! Using %s..."):format(tileInfo.Type, Config.DICE_TYPE))
                    turnResponse = takeTurn(Config.DICE_TYPE)
                    updateStatsUI()
                    actionTaken = true
                    break
                end
            end
        end

        -- Default roll if no target
        if not actionTaken then
            log(("No targets in range. Rolling with %s..."):format(Config.DICE_TYPE))
            turnResponse = takeTurn(Config.DICE_TYPE)
            updateStatsUI()
        end

        -- Chance tile delay
        if turnResponse then
            local idx = turnResponse.Tile and turnResponse.Tile.Index
            local landedTileInfo = idx and BoardUtil.Nodes[idx]
            if landedTileInfo and landedTileInfo.Type == "chance" then
                log(("Landed on 'chance'. Waiting %.1fs for animation..."):format(Config.DelayForChanceTile))
                task.wait(Config.DelayForChanceTile)
            end
        end

        task.wait(0.1)
    end

    Running = false
    log("Auto-Dice loop: STOPPED")
end

--== WindUI Controls ==--
local StatusLine = Section:Paragraph({ Title = "Status", Desc = "Idle" })
local StatsBox = Section:Paragraph({ Title = "Session Stats", Desc = "Rolls: 0 | Golden Dice: 0\nNo target tiles hit yet." })

local function updateStatsUI()
    StatsBox:SetDesc(string.format(
        "Rolls: %d | Golden Dice: %d\n%s",
        Stats.TotalRolls, Stats.GoldenDiceUses, formatTargetHits()
    ))
end

Section:Toggle({
    Flag = "AutoBoardGame",
    Title = "Auto Board Game",
    Value = Config.AutoBoardGame,
    Callback = function(state)
        Config.AutoBoardGame = state
        if state then
                        task.spawn(function() mainLoop(updateStatsUI) end)
        else
                    end
    end
})

--== Live Status Updater ==--
task.spawn(function()
    while true do
        if Config.AutoBoardGame then
            local idx = LocalPlayer:GetAttribute("BoardIndex")
            local tileType = "?"
            local node = idx and BoardUtil.Nodes[idx]
            if node and node.Type then tileType = node.Type end
            StatusLine:SetDesc(string.format(
                "Running â¢ Current Tile: %s â¢ Dice: %s â¢ Tile: %s",
                tostring(idx or "?"), tostring(Config.DICE_TYPE), tostring(tileType)
            ))
        else
            StatusLine:SetDesc("Idle")
        end
        task.wait(0.4)
    end
end)

--== Tips ==--
-- MinigamesTab:Divider()
-- Section:Paragraph({
--     Title = "Tips",
--     Desc = table.concat({
--         "â¢ Bot snipes close target tiles with Golden Dice.",
--         "â¢ Dice Type sets the default roll when no targets in range.",
--         "â¢ See per-target hit counts below the stats box.",
--         "â¢ Toggle 'Auto Board Game' to start/stop automation.",
--     }, "\n")
-- })

Section:Paragraph({ Title = "Controls" })

local allTileTypes = { "special-egg", "infinity", "golden-dice", "giant-dice", "dice", "dice-key", "chance", "basic" }

Section:Dropdown({
    Flag = "TargetTileTypes",
    Title = "Target Tile Types",
    Values = allTileTypes,
    Multi = true,
    Value = (function()
        local sel = {}
        for _, t in ipairs(allTileTypes) do
            if Config.TILES_TO_TARGET[t] then table.insert(sel, t) end
        end
        return sel
    end)(),
    Callback = function(selected)
        Config.TILES_TO_TARGET = {}
        for _, t in ipairs(selected) do
            Config.TILES_TO_TARGET[t] = true
        end
            end
})

Section:Dropdown({
    Flag = "DiceTypeToUse",
    Title = "Dice Type to Use",
    Values = { "Dice", "Giant Dice", "Golden Dice" },
    Multi = false,
    Value = Config.DICE_TYPE,
    Callback = function(val)
        Config.DICE_TYPE = val
            end
})

Section:Slider({
    Flag = "GoldenDiceSnipeDistance",
    Title = "Golden Dice Snipe Distance",
    Step = 1,
    Value = { Min=1, Max=10, Default=Config.GOLDEN_DICE_DISTANCE },
        Callback = function(v)
        Config.GOLDEN_DICE_DISTANCE = math.floor(v)
    end
})

-- Section:Toggle({
    -- Flag = "VerboseConsoleLogs",
--     Title = "Verbose Console Logs",
--     Value = Config.Verbose,
--     Callback = function(state)
--         Config.Verbose = state
--     end
-- })

--== Auto Minigame (Appended below Auto Dice) ==--
--== Services & Network (Minigame) ==--
local RunService = game:GetService("RunService")

--== Services & Network ==--
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RemoteEvent = ReplicatedStorage.Shared.Framework.Network.Remote.RemoteEvent

local function startMinigame(gameName, difficulty)
    RemoteEvent:FireServer("StartMinigame", gameName, difficulty)
end

local function finishMinigame()
    RemoteEvent:FireServer("FinishMinigame")
end

local function skipMinigameCooldown(gameName)
    RemoteEvent:FireServer("SkipMinigameCooldown", gameName)
end

--== Patch transitions/minigames ==--
if not hookfunction then
    return
end

local transitionPatched = false
local cameraPatched = false

local playTransitionModule = ReplicatedStorage:FindFirstChild("PlayTransition", true)
if playTransitionModule then
    local originalTransitionFunc = require(playTransitionModule)
    local function skipTransition(text, callback, icon)
        if typeof(callback) == "function" then
            task.spawn(callback)
        end
    end
    hookfunction(originalTransitionFunc, skipTransition)
    transitionPatched = true
end

local petMatchModule = ReplicatedStorage:FindFirstChild("Client"):FindFirstChild("Gui"):FindFirstChild("Frames"):FindFirstChild("Minigames"):FindFirstChild("Pet Match")
if petMatchModule and petMatchModule:IsA("ModuleScript") then
    local originalRunFunction = require(petMatchModule)
    local function ignoreMinigameLogic(...)
        local function emptyFunc() end
        return emptyFunc, emptyFunc
    end
    hookfunction(originalRunFunction, ignoreMinigameLogic)
    cameraPatched = true
end

local minecartEscapeModule = ReplicatedStorage:FindFirstChild("Client"):FindFirstChild("Gui"):FindFirstChild("Frames"):FindFirstChild("Minigames"):FindFirstChild("Minecart Escape")
if minecartEscapeModule and minecartEscapeModule:IsA("ModuleScript") then
    local originalRunFunction = require(minecartEscapeModule)
    local function ignoreMinigameLogic(...)
        local function emptyFunc() end
        return emptyFunc, emptyFunc
    end
    hookfunction(originalRunFunction, ignoreMinigameLogic)
    cameraPatched = true
end

local robotClawModule = ReplicatedStorage:FindFirstChild("Client"):FindFirstChild("Gui"):FindFirstChild("Frames"):FindFirstChild("Minigames"):FindFirstChild("Robot Claw")
if robotClawModule and robotClawModule:IsA("ModuleScript") then
    local originalRunFunction = require(robotClawModule)
    local function ignoreMinigameLogic(...)
        local function emptyFunc() end
        return emptyFunc, emptyFunc
    end
    hookfunction(originalRunFunction, ignoreMinigameLogic)
    cameraPatched = true
end

local hyperDartsModule = ReplicatedStorage:FindFirstChild("Client"):FindFirstChild("Gui"):FindFirstChild("Frames"):FindFirstChild("Minigames"):FindFirstChild("Hyper Darts")
if hyperDartsModule and hyperDartsModule:IsA("ModuleScript") then
    local originalRunFunction = require(hyperDartsModule)
    local function ignoreMinigameLogic(...)
        local function emptyFunc() end
        return emptyFunc, emptyFunc
    end
    hookfunction(originalRunFunction, ignoreMinigameLogic)
    cameraPatched = true
end

--== Section: Minigames Controls ==--
local MinigamesSection = MinigamesTab:Section({
    Title = "Auto Minigame",
    TextXAlignment = "Left",
    TextSize = 17,
    Opened = false,
})

--== Section: Minigames Controls ==--
-- Core state
local timesRan = timesRan or 0  -- successful minigame runs since last ON
local startTime = nil
local selectedDifficulty = "Easy"
local selectedGameName = "Pet Match"
local autoMinigameEnabled = false

local GAME_NAME_MAP = {
    ["Pet Match"] = "Pet Match",
    ["Minecart Forest"] = "Cart Escape",
    ["Robot Claw"] = "Robot Claw",
    ["Hyper Darts"] = "Hyper Darts",
}

local StatusPara = MinigamesSection:Paragraph({
    Title = "Status",
    Desc = ""
})

--============================================================--
--                 LocalData Watcher + Deltas                 --
--============================================================--

-- CONFIG
local POLL_SECONDS = 1.5        -- How often to poll LocalData
local PRINT_ON_CHANGE = true    -- Console: only when tracked values change
local SHOW_BASELINE_PRINT = true

-- LocalData access helpers
local function path(root, ...)
    local node = root
    for _, name in ipairs({...}) do
        node = node and node:FindFirstChild(name)
        if not node then return nil end
    end
    return node
end

local function findLocalData()
    return path(ReplicatedStorage, "Client", "Framework", "Services", "LocalData")
end

local LocalDataInst = findLocalData()
local LocalDataObj do
    if LocalDataInst and LocalDataInst:IsA("ModuleScript") then
        local ok, mod = pcall(require, LocalDataInst)
        LocalDataObj = ok and mod or nil
        if not ok then warn("[LocalData] require() failed:", mod) end
    else
        LocalDataObj = LocalDataInst -- could be Instance with Get/Invoke
    end
end

local function safeGet(obj)
    if obj and typeof(obj) == "table" and type(obj.Get) == "function" then
        local ok, data = pcall(function() return obj:Get() end)
        return ok and data or nil
    end
    if typeof(obj) == "Instance" then
        if obj:IsA("BindableFunction") then
            local ok, data = pcall(function() return obj:Invoke() end)
            return ok and data or nil
        elseif obj:IsA("RemoteFunction") then
            local ok, data = pcall(function() return obj:InvokeServer("Get") end)
            return ok and data or nil
        elseif type(obj.Get) == "function" then
            local ok, data = pcall(function() return obj:Get() end)
            return ok and data or nil
        end
    end
    return nil
end

local POWERUP_KEYS = {
    ["Super Tickets"] = "Super Ticket",
    ["Golden Dice"]   = "Golden Dice",
    ["Giant Dice"]    = "Giant Dice",
    ["Dice"]          = "Dice",
    ["Dice Keys"]     = "Dice Key",
}

local POTION_NAMES = {
    ["Infinity Elixir"] = true,
    ["Secret Elixir"]   = true,
}

local PRINT_ORDER = {
    "Infinity Elixir",
    "Secret Elixir",
    "Golden Dice",
    "Giant Dice",
    "Dice",
    "Dice Keys",
    "Super Tickets",
}

local function formatInt(n)
    n = tonumber(n) or 0
    local s = tostring(math.floor(n + 0.5))
    local left, num, right = s:match("^([^%d]*%d)(%d*)(.-)$")
    num = (num or ""):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
    return (left or "") .. (num or "") .. (right or "")
end

local function extractTracked(data)
    if type(data) ~= "table" then return nil end
    local powerups = data.Powerups or {}
    local potions  = data.Potions or {}
    local out = {}

    for name in pairs(POTION_NAMES) do out[name] = 0 end
    for _, p in ipairs(potions) do
        if POTION_NAMES[p.Name] then
            out[p.Name] = (out[p.Name] or 0) + (tonumber(p.Amount) or 0)
        end
    end

    for label, key in pairs(POWERUP_KEYS) do
        out[label] = tonumber(powerups[key]) or 0
    end
    return out
end

local function diff(old, new)
    local changes = {}
    for _, label in ipairs(PRINT_ORDER) do
        local a = old and old[label] or nil
        local b = new and new[label] or nil
        if a == nil or b == nil or a ~= b then
            table.insert(changes, {
                label = label,
                old = a,
                new = b,
                delta = (a and b) and (b - a) or nil
            })
        end
    end
    return changes
end

local function anyChanges(changes)
    for _ in ipairs(changes) do return true end
    return false
end

local function printChanges(changes)
    if not PRINT_ON_CHANGE then return end
    
    for _, label in ipairs(PRINT_ORDER) do
        for _, c in ipairs(changes) do
            if c.label == label then
                local oldStr = (c.old == nil) and "â" or formatInt(c.old)
                local newStr = (c.new == nil) and "â" or formatInt(c.new)
                local deltaStr = ""
                if c.delta then
                    local sign = (c.delta > 0) and "+" or ""
                    deltaStr = (" (%s%s)"):format(sign, formatInt(c.delta))
                end
                
            end
        end
    end
end

local InvSnapshot = nil
local InvCurrent  = nil
local lasInv     = nil
local lastFetchT = 0
local consecutiveErrors = 0

local function calcDeltas(base, curr)
    local deltas = {}
    if not base or not curr then return deltas end
    for _, name in ipairs(PRINT_ORDER) do
        local b = base[name] or 0
        local c = curr[name] or 0
        deltas[name] = c - b
    end
    return deltas
end

local function ticketsUsedSinceStart(base, curr)
    if not base or not curr then return 0 end
    local b = base["Super Tickets"] or 0
    local c = curr["Super Tickets"] or 0
    local used = b - c
    return (used > 0) and used or 0
end

local function updateStatus()
    local elapsed = startTime and math.floor(tick() - startTime) or 0
    local status = autoMinigameEnabled and "Running" or "Stopped"

    local lines = {
        ("Status: %s"):format(status),
        ("Difficulty: %s"):format(selectedDifficulty),
        ("Game: %s"):format(selectedGameName),
        ("Time Elapsed: %d seconds"):format(elapsed)
    }

    if InvSnapshot and InvCurrent then
        local deltas = calcDeltas(InvSnapshot, InvCurrent)
        table.insert(lines, "")
        table.insert(lines, "Gained Since Start:")
        for _, name in ipairs(PRINT_ORDER) do
            if name ~= "Super Tickets" then
                local d = deltas[name] or 0
                if d ~= 0 then
                    table.insert(lines, ("â¢ %s: %s (%s)"):format(
                        name,
                        (d > 0 and "+" or "") .. formatInt(d),
                        formatInt((InvCurrent and InvCurrent[name]) or 0)
                    ))
                end
            end
        end
        do
            local dST = (deltas and deltas["Super Tickets"]) or 0
            if dST > 0 then
                table.insert(lines, ("â¢ Super Tickets gained: +%s (%s)"):format(
                    formatInt(dST),
                    formatInt((InvCurrent and InvCurrent["Super Tickets"]) or 0)
                ))
            end
        end
        table.insert(lines, ("â¢ Super Tickets used: %s"):format(formatInt(ticketsUsedSinceStart(InvSnapshot, InvCurrent))))
    else
        table.insert(lines, "")
        table.insert(lines, "Gained Since Start: (â)")
        table.insert(lines, "â¢ Super Tickets used: 0")
    end

    local desc = table.concat(lines, "\n")
    if StatusPara and StatusPara.SetDesc then
        StatusPara:SetDesc(desc)
    else
        
    end
end

task.spawn(function()
    while true do
        updateStatus()
        task.wait(0.5)
    end
end)

local function refreshSnapshots()
    if not LocalDataObj then return end
    local now = tick()
    if now - lastFetchT < POLL_SECONDS then return end
    lastFetchT = now

    local data = safeGet(LocalDataObj)
    if not data then
        consecutiveErrors += 1
        if consecutiveErrors <= 3 then
            warn("[LocalData] Get() failed (attempt " .. consecutiveErrors .. ")")
        end
        return
    end
    consecutiveErrors = 0

    InvCurrent = extractTracked(data)

    if autoMinigameEnabled and not InvSnapshot and InvCurrent then
        InvSnapshot = table.clone(InvCurrent)
        if SHOW_BASELINE_PRINT and PRINT_ON_CHANGE then
            
            for _, label in ipairs(PRINT_ORDER) do
                
            end
        end
        lasInv = table.clone(InvSnapshot)
    end

    if PRINT_ON_CHANGE and InvCurrent and lasInv then
        local changes = diff(lasInv, InvCurrent)
        if anyChanges(changes) then
            printChanges(changes)
            lasInv = table.clone(InvCurrent)
        end
    end
end

RunService.Heartbeat:Connect(function()
    refreshSnapshots()
end)

MinigamesSection:Dropdown({
    Flag = "MGDIFF",
    Title = "Difficulty",
    Value = selectedDifficulty,
    Values = {"Easy","Medium","Hard","Insane"},
    Callback = function(Value)
        selectedDifficulty = Value
        updateStatus()
    end
})

MinigamesSection:Dropdown({
    Flag = "MGNAME",
    Title = "Game",
    Value = selectedGameName,
    Values = {"Pet Match","Minecart Forest","Robot Claw","Hyper Darts"},
    Callback = function(Value)
        selectedGameName = Value
        if Value == "Hyper Darts" then
                    end
        updateStatus()
    end
})

MinigamesSection:Toggle({
    Flag = "AMGTOGGLE",
    Title = "Auto Minigame",
    Value = false,
    Callback = function(Value)
        autoMinigameEnabled = Value
        _G.__AMG_RUN_TOKEN = (_G.__AMG_RUN_TOKEN or 0) + 1
        local runToken = _G.__AMG_RUN_TOKEN

        if Value then
            timesRan          = 0
            startTime         = tick()
            InvSnapshot  = nil
            InvCurrent   = nil
            lasInv      = nil
            lastFetchT        = 0

            task.spawn(function()
                while autoMinigameEnabled and runToken == _G.__AMG_RUN_TOKEN do
                    local remoteGameName = (GAME_NAME_MAP and GAME_NAME_MAP[selectedGameName]) or selectedGameName

                    pcall(function()
                        RemoteEvent:FireServer("StartMinigame", remoteGameName, selectedDifficulty)
                    end)

                    task.wait(0.1)

                    local success, err = pcall(function()
                        RemoteEvent:FireServer("FinishMinigame")
                    end)

                    if not success then
                        warn("Failed to finish minigame: " .. tostring(err))
                        updateStatus()
                        task.wait(1)
                    else
                        pcall(function()
                            RemoteEvent:FireServer("SkipMinigameCooldown", remoteGameName)
                        end)

                        timesRan = (timesRan or 0) + 1
                    end

                    task.wait(0.1)
                end
            end)
        else
            startTime         = nil
            InvSnapshot  = nil
            InvCurrent   = nil
            lasInv      = nil
        end

        updateStatus()
    end
})

function RecordMinigameSuccess()
    timesRan = (timesRan or 0) + 1
    if updateStatus then updateStatus() end
end

OnMinigameSuccess = RecordMinigameSuccess



-- === CONFIG (sparse, debounced) — full replacement (with Window.ConfigManager + Settings proxy) ===

local RCH_Http       = RCH_Http       or game:GetService("HttpService")
local RCH_ConfigName = RCH_ConfigName or "RcashHub_Config"
local RCH_FOLDER     = RCH_FOLDER     or "rcashhub-config"
local RCH_FILE       = RCH_FILE       or (RCH_FOLDER .. "/autosave.json")

local function RCH_ensureFolder()
    if typeof(makefolder) == "function" then pcall(makefolder, RCH_FOLDER) end
end

-- (optional) Window.ConfigManager compat so your Save/Load buttons keep working
local function RCH_getConfig()
    if Window and Window.ConfigManager and typeof(Window.ConfigManager.CreateConfig) == "function" then
        Window.CurrentConfig = Window.CurrentConfig or Window.ConfigManager:CreateConfig(RCH_ConfigName)
        return Window.CurrentConfig
    end
end

-- ===== Sparse, debounced autosave engine =====
local function deepCopy(src)
    if type(src) ~= "table" then return src end
    local dst = {}
    for k,v in pairs(src) do dst[k] = deepCopy(v) end
    return dst
end
local function deepEqual(a,b)
    if a == b then return true end
    if type(a) ~= "table" or type(b) ~= "table" then return false end
    for k,v in pairs(a) do if not deepEqual(v, b[k]) then return false end end
    for k,_ in pairs(b) do if a[k] == nil then return false end end
    return true
end
local function pruneEmpty(t)
    if type(t) ~= "table" then return false end
    local empty = true
    for k,v in pairs(t) do
        if type(v) == "table" then
            if not pruneEmpty(v) then empty = false else t[k] = nil end
        else
            empty = false
        end
    end
    return empty
end
local function merge(defaults, overrides)
    if type(overrides) ~= "table" then
        return overrides ~= nil and overrides or deepCopy(defaults)
    end
    local out = deepCopy(defaults or {})
    for k,v in pairs(overrides) do
        if type(v) == "table" and type(out[k]) == "table" then
            out[k] = merge(out[k], v)
        else
            out[k] = deepCopy(v)
        end
    end
    return out
end
local function splitPath(path)
    local t = {}
    for part in string.gmatch(path, "[^%.]+") do t[#t+1] = part end
    return t
end
local function setOverride(overrides, defaults, path, value)
    local parts = type(path) == "table" and path or splitPath(path)
    local nodeO, nodeD = overrides, defaults
    for i = 1, #parts - 1 do
        local p = parts[i]
        nodeO[p] = nodeO[p] or {}
        nodeO = nodeO[p]
        nodeD = (type(nodeD) == "table") and nodeD[p] or nil
    end
    local leaf = parts[#parts]
    local defaultVal = (type(nodeD) == "table") and nodeD[leaf] or nil
    if deepEqual(value, defaultVal) then
        nodeO[leaf] = nil
    else
        nodeO[leaf] = deepCopy(value)
    end
    pruneEmpty(overrides)
end
local function fsOK()
    return typeof(isfile)=="function" and typeof(writefile)=="function" and typeof(readfile)=="function"
end

local SparseConfig = {}
function SparseConfig.new(opts)
    local self = {}
    self.file        = opts.file or "config.json"
    self.defaults    = deepCopy(opts.defaults or {})
    self.overrides   = {}
    self.enabled     = (opts.enabled ~= false)
    self.debounce    = tonumber(opts.debounce) or 1.0
    self.maxInterval = tonumber(opts.max_interval) or 30.0
    self._started, self._dirty = false, false
    self._lastSerialized, self._nextDue = nil, math.huge
    self._lastSave = 0

    function self:load()
        if fsOK() and isfile(self.file) then
            local ok, data = pcall(readfile, self.file)
            if ok and data and #data > 0 then
                local ok2, json = pcall(function() return RCH_Http:JSONDecode(data) end)
                if ok2 and type(json)=="table" then
                    self.overrides = json
                end
            end
        end
        return merge(self.defaults, self.overrides)
    end

    function self:_serialize()
        return RCH_Http:JSONEncode(self.overrides)
    end

    function self:_saveNow()
        if not (self.enabled and fsOK()) then return end
        pruneEmpty(self.overrides)
        local s = self:_serialize()
        if s ~= self._lastSerialized then
            pcall(writefile, self.file, s)
            self._lastSerialized = s
        end
        self._dirty = false
        self._lastSave = os.clock()
        self._nextDue = math.huge
    end

    function self:_ensureLoop()
        if self._started then return end
        self._started = true
        task.spawn(function()
            while true do
                local dueAt = math.min(self._nextDue, (self._lastSave + self.maxInterval))
                local sleepFor = math.max(0.05, dueAt - os.clock())
                task.wait(sleepFor)
                if not self.enabled then
                    self._nextDue = math.huge
                    task.wait(1.0)
                else
                    local now = os.clock()
                    if self._dirty and (now >= self._nextDue or (now - self._lastSave) >= self.maxInterval) then
                        self:_saveNow()
                    end
                end
            end
        end)
        game:BindToClose(function()
            if self._dirty then self:_saveNow() end
        end)
    end

    function self:markDirty()
        self._dirty = true
        self._nextDue = os.clock() + self.debounce
        self:_ensureLoop()
    end

    function self:set(path, value)
        setOverride(self.overrides, self.defaults, path, value)
        self:markDirty()
    end

    function self:rebuildFromState(curr)
        local function buildDelta(currTbl, defTbl)
            if type(currTbl) ~= "table" or type(defTbl) ~= "table" then
                return deepEqual(currTbl, defTbl) and nil or deepCopy(currTbl)
            end
            local out = {}
            for k,v in pairs(currTbl) do
                local d = defTbl[k]
                local sub = buildDelta(v, d)
                if sub ~= nil then out[k] = sub end
            end
            return next(out) and out or nil
        end
        self.overrides = buildDelta(curr, self.defaults) or {}
        self:markDirty()
    end

    function self:setEnabled(on)
        self.enabled = not not on
    end

    return self
end

-- ===== Engine wiring & public API =====

-- Build DEFAULTS once (baseline UI/Settings at startup)
local DEFAULTS = (type(RCH_buildSnapshot)=="function" and RCH_buildSnapshot()) or { flags = {}, settings = {} }

RCH_ensureFolder()
local __Sparse = SparseConfig.new({
    file         = RCH_FILE,
    defaults     = DEFAULTS,
    debounce     = 1.0,      -- save 1s after last change burst
    max_interval = 30.0,     -- safety flush at least every 30s while dirty
    enabled      = true
})

-- Load overrides and apply to UI/Settings
local __STATE = __Sparse:load()
if type(__STATE) == "table" and type(RCH_applySnapshot) == "function" then
    pcall(RCH_applySnapshot, __STATE)
end
_G.__RCH_LatestSnap = __STATE

-- Make _G.Settings a proxy so direct writes auto-mark dirty
do
    _G.Settings = _G.Settings or {}
    local raw = _G.Settings
    if getmetatable(raw) == nil then
        local proxy = setmetatable({}, {
            __index = raw,
            __newindex = function(_, k, v)
                raw[k] = v
                if typeof(v) == "number" or typeof(v) == "string" or typeof(v) == "boolean" then
                    __STATE.settings = __STATE.settings or {}
                    __STATE.settings[k] = v
                    if __Sparse and __Sparse.set then __Sparse:set("settings." .. tostring(k), v) end
                end
            end,
            __pairs = function() return next, raw, nil end
        })
        _G.Settings = proxy
    end
end

-- Single-flag update for UI elements that use .Flag callbacks
function _G.RCH_UpdateOne(flag, value)
    if not flag then return end
    local encoded = RCH_encodeValue(value)
    __STATE.flags = __STATE.flags or {}
    __STATE.flags[flag] = encoded
    __Sparse:set("flags." .. tostring(flag), encoded)
    _G.__RCH_LatestSnap = __STATE
end

-- Manual save: try Window.ConfigManager first, then flush sparse
function _G.__autoSaveConfig()
    local cfg = RCH_getConfig()
    if cfg and typeof(cfg.Save) == "function" then pcall(function() cfg:Save() end) end
    if type(RCH_copySettings) == "function" then
        __STATE.settings = RCH_copySettings()
        __Sparse:set("settings", __STATE.settings)
    end
    local _saveNow = rawget(__Sparse, "_saveNow")
    if _saveNow then _saveNow(__Sparse) end
end

-- Manual load: try Window.ConfigManager, else sparse file
function _G.RCH_LoadConfig()
    local cfg = RCH_getConfig()
    if cfg and typeof(cfg.Load) == "function" then
        local ok = false
        pcall(function() ok = cfg:Load() end)
        if ok then
            local snap = RCH_buildSnapshot()
            __STATE = snap
            _G.__RCH_LatestSnap = __STATE
            __Sparse:rebuildFromState(snap) -- compress + mark dirty
            return true
        end
    end
    local ok2, loaded = pcall(function() return __Sparse:load() end)
    if not ok2 or type(loaded) ~= "table" then return false end
    __STATE = loaded
    _G.__RCH_LatestSnap = __STATE
    if type(RCH_applySnapshot) == "function" then
        local ok3 = pcall(RCH_applySnapshot, loaded)
        return ok3 and true or false
    end
    return true
end

-- UI toggle redirects (legacy flag stays false so old watcher never re-enables)
_G.__RCH_AutoSaveEnabled = false
function _G.__RCH_StartAutoSave()
    __Sparse:setEnabled(true)
    _G.__RCH_AutoSaveEnabled = false
end
function _G.__RCH_StopAutoSave()
    __Sparse:setEnabled(false)
    _G.__RCH_AutoSaveEnabled = false
end

-- Hook UI elements that have .Flag so Set/Select will call RCH_UpdateOne
do
    local function hookFlagElements()
        local ok, byFlag = pcall(RCH_collectByFlag)
        if not ok or type(byFlag) ~= "table" then return end
        _G.__RCH_FLAG_HOOKED = _G.__RCH_FLAG_HOOKED or {}
        for flag, elm in pairs(byFlag) do
            if elm and not _G.__RCH_FLAG_HOOKED[elm] then
                _G.__RCH_FLAG_HOOKED[elm] = true
                pcall(function()
                    if typeof(elm.Set) == "function" then
                        local _orig = elm.Set
                        elm.Set = function(self, v, ...)
                            local r = _orig(self, v, ...)
                            if not _G.__RCH_Loading and _G.RCH_UpdateOne then
                                local cv = RCH_readElement(self)
                                _G.RCH_UpdateOne(flag, cv ~= nil and cv or v)
                            end
                            return r
                        end
                    end
                end)
                pcall(function()
                    if typeof(elm.Select) == "function" then
                        local _origS = elm.Select
                        elm.Select = function(self, v, ...)
                            local r = _origS(self, v, ...)
                            if not _G.__RCH_Loading and _G.RCH_UpdateOne then
                                local cv = RCH_readElement(self)
                                _G.RCH_UpdateOne(flag, cv ~= nil and cv or v)
                            end
                            return r
                        end
                    end
                end)
            end
        end
    end
    task.defer(function()
        for i = 1, 30 do
            hookFlagElements()
            task.wait(0.25)
        end
    end)
end

-- Lightweight Settings watcher (1s diff) to catch direct writes
task.spawn(function()
    local last = {}
    while true do
        task.wait(1.0)
        local ok, cur = pcall(RCH_copySettings)
        if not ok or type(cur) ~= "table" then continue end
        for k,v in pairs(cur) do
            if last[k] ~= v then
                __STATE = __STATE or { flags = {}, settings = {} }
                __STATE.settings = __STATE.settings or {}
                __STATE.settings[k] = v
                if __Sparse and __Sparse.set then __Sparse:set("settings." .. tostring(k), v) end
            end
        end
        for k,_ in pairs(last) do
            if cur[k] == nil then
                if __STATE and __STATE.settings then __STATE.settings[k] = nil end
                if __Sparse and __Sparse.set then __Sparse:set("settings." .. tostring(k), nil) end
            end
        end
        last = cur
    end
end)

-- === /CONFIG (sparse, debounced) ===

do
    if SpawnerSection then
        SpawnerSection:Divider()
        SpawnerSection:Paragraph({ Title = "Fallback Eggs", Desc = "Used if your target Rift is missing or despawns." })
        local FallbackSection = SpawnerSection

        FallbackSection:Toggle({
            Flag = "FallbackEnabled",
            Title = "Use Fallback Eggs",
            Value = __FallbackEnabled or false,
        Callback = function(v) __FallbackEnabled = v and true or false end
        })

        FallbackSection:Dropdown({
            Flag = "HunterFallbackEgg",
            Title = "Hunter Fallback Egg",
            Values = (type(__getFallbackEggList)=="function" and __getFallbackEggList()) or EggNames,
            Value = (__HunterFallback and __HunterFallback.egg) or "",
            Multi = false,
        Callback = function(v)
                __HunterFallback = __HunterFallback or {}
                __HunterFallback.egg = v
            end
        })

        FallbackSection:Dropdown({
            Flag = "SpawnerFallbackEgg",
            Title = "Spawner Fallback Egg",
            Values = (type(__getFallbackEggList)=="function" and __getFallbackEggList()) or EggNames,
            Value = (__SpawnerFallback and __SpawnerFallback.egg) or "",
            Multi = false,
        Callback = function(v)
                __SpawnerFallback = __SpawnerFallback or {}
                __SpawnerFallback.egg = v
            end
        })
    end
end